interactive_expr: Begin Case Verbatim Of LBRACKET WILD ARROW Skip With
##
## Ends in an error in state: 591.
##
## terse_case(test_clause(instruction)) -> Case expr Of LBRACKET cases(test_clause(instruction)) . RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET cases(test_clause(instruction))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 584, spurious reduction of production nsepseq(case_clause(test_clause(instruction)),VBAR) -> case_clause(test_clause(instruction))
## In state 581, spurious reduction of production cases(test_clause(instruction)) -> nsepseq(case_clause(test_clause(instruction)),VBAR)
##
interactive_expr: Begin Case UIdent Of LBRACKET VBAR UIdent ARROW Skip While
##
## Ends in an error in state: 589.
##
## terse_case(test_clause(instruction)) -> Case expr Of LBRACKET VBAR cases(test_clause(instruction)) . RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET VBAR cases(test_clause(instruction))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 584, spurious reduction of production nsepseq(case_clause(test_clause(instruction)),VBAR) -> case_clause(test_clause(instruction))
## In state 581, spurious reduction of production cases(test_clause(instruction)) -> nsepseq(case_clause(test_clause(instruction)),VBAR)
##

Ill-formed case instruction.
At this point, if the clause is complete, one of the following is
expected:
  * a vertical bar '|' followed by another clause;
  * a closing bracket ']' if the case is complete.
Note: A clause, here, is made of a pattern and an instruction or
a block of statements, separated by an arrow '->'.

interactive_expr: Case UIdent Of LBRACKET VBAR UIdent ARROW UIdent While
##
## Ends in an error in state: 662.
##
## terse_case(expr) -> Case expr Of LBRACKET VBAR cases(expr) . RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET VBAR cases(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 653, spurious reduction of production case_clause(expr) -> pattern ARROW expr
## In state 657, spurious reduction of production nsepseq(case_clause(expr),VBAR) -> case_clause(expr)
## In state 654, spurious reduction of production cases(expr) -> nsepseq(case_clause(expr),VBAR)
##
interactive_expr: Case UIdent Of LBRACKET UIdent ARROW UIdent While
##
## Ends in an error in state: 664.
##
## terse_case(expr) -> Case expr Of LBRACKET cases(expr) . RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET cases(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 653, spurious reduction of production case_clause(expr) -> pattern ARROW expr
## In state 657, spurious reduction of production nsepseq(case_clause(expr),VBAR) -> case_clause(expr)
## In state 654, spurious reduction of production cases(expr) -> nsepseq(case_clause(expr),VBAR)
##

Ill-formed case expression.
At this point, if the clause is complete, one of the following is
expected:
  * a vertical bar '|' followed by another clause;
  * a closing bracket ']' if the case is complete.
Note: A clause, here, is made of a pattern and an expression separated
by an arrow '->'.

interactive_expr: Begin Case UIdent Of VBAR With
##
## Ends in an error in state: 551.
##
## verb_case(test_clause(instruction)) -> Case expr Of VBAR . cases(test_clause(instruction)) End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of VBAR
##
interactive_expr: Begin Case UIdent Of LBRACKET VBAR With
##
## Ends in an error in state: 588.
##
## terse_case(test_clause(instruction)) -> Case expr Of LBRACKET VBAR . cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET VBAR
##
interactive_expr: Begin Case Verbatim Of WILD ARROW Skip VBAR With
##
## Ends in an error in state: 585.
##
## nsepseq(case_clause(test_clause(instruction)),VBAR) -> case_clause(test_clause(instruction)) VBAR . nsepseq(case_clause(test_clause(instruction)),VBAR) [ RBRACKET End ]
##
## The known suffix of the stack is as follows:
## case_clause(test_clause(instruction)) VBAR
##

Ill-formed case instruction.
At this point, a clause is expected, starting with a pattern.
Note: A clause, here, is made of a pattern and an instruction or
a block of statements, separated by an arrow '->'.

interactive_expr: Begin Case Verbatim Of LBRACKET With
##
## Ends in an error in state: 587.
##
## terse_case(test_clause(instruction)) -> Case expr Of LBRACKET . cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## terse_case(test_clause(instruction)) -> Case expr Of LBRACKET . VBAR cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET
##

Ill-formed case instruction.
At this point, one of the following is expected:
  * a clause, starting with a pattern;
  * a vertical bar '|' followed by a clause.

interactive_expr: Begin Case Verbatim Of With
##
## Ends in an error in state: 550.
##
## terse_case(test_clause(instruction)) -> Case expr Of . LBRACKET cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## terse_case(test_clause(instruction)) -> Case expr Of . LBRACKET VBAR cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## verb_case(test_clause(instruction)) -> Case expr Of . cases(test_clause(instruction)) End [ VBAR SEMI RBRACKET RBRACE End Else ]
## verb_case(test_clause(instruction)) -> Case expr Of . VBAR cases(test_clause(instruction)) End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of
##

Ill-formed case instruction.
At this point, one of the following is expected:
  * a clause, starting with a pattern;
  * a vertical bar '|' followed by a clause;
  * an opening bracket '['.
Note: A clause, here, is made of a pattern and an instruction or
a block of statements, separated by an arrow '->'.

interactive_expr: Begin Case Verbatim Of WILD ARROW Skip With
##
## Ends in an error in state: 593.
##
## verb_case(test_clause(instruction)) -> Case expr Of cases(test_clause(instruction)) . End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of cases(test_clause(instruction))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 584, spurious reduction of production nsepseq(case_clause(test_clause(instruction)),VBAR) -> case_clause(test_clause(instruction))
## In state 581, spurious reduction of production cases(test_clause(instruction)) -> nsepseq(case_clause(test_clause(instruction)),VBAR)
##
interactive_expr: Begin Case UIdent Of VBAR UIdent ARROW Skip While
##
## Ends in an error in state: 582.
##
## verb_case(test_clause(instruction)) -> Case expr Of VBAR cases(test_clause(instruction)) . End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of VBAR cases(test_clause(instruction))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 584, spurious reduction of production nsepseq(case_clause(test_clause(instruction)),VBAR) -> case_clause(test_clause(instruction))
## In state 581, spurious reduction of production cases(test_clause(instruction)) -> nsepseq(case_clause(test_clause(instruction)),VBAR)
##

Ill-formed case instruction.
At this point, if the clause is complete, one of the following is
expected:
  * a vertical bar '|' followed by another clause;
  * the keyword 'end' if the case is complete.
Note: A clause, here, is made of a pattern and an instruction or
a block of statements, separated by an arrow '->'.

interactive_expr: Begin Case Verbatim Of WILD ARROW With
##
## Ends in an error in state: 553.
##
## case_clause(test_clause(instruction)) -> pattern ARROW . test_clause(instruction) [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

Ill-formed clause of a case instruction.
At this point, one of the following is expected:
  * a single instruction;
  * a block of statements (instructions and declarations).
Note: A block is either delimited by '{' and '}' (terse dialect) or
'begin' and 'end' (verbose dialect).

interactive_expr: Begin Case Verbatim Of WILD With
##
## Ends in an error in state: 552.
##
## case_clause(test_clause(instruction)) -> pattern . ARROW test_clause(instruction) [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 261, spurious reduction of production pattern -> core_pattern
##

Ill-formed clause of a case instruction.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by either
  * a single instruction;
  * a block of statements (instructions and declarations).
Note: A block is either delimited by '{' and '}' (terse dialect) or
'begin' and 'end' (verbose dialect).

interactive_expr: Begin Case With
##
## Ends in an error in state: 548.
##
## terse_case(test_clause(instruction)) -> Case . expr Of LBRACKET cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## terse_case(test_clause(instruction)) -> Case . expr Of LBRACKET VBAR cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## verb_case(test_clause(instruction)) -> Case . expr Of cases(test_clause(instruction)) End [ VBAR SEMI RBRACKET RBRACE End Else ]
## verb_case(test_clause(instruction)) -> Case . expr Of VBAR cases(test_clause(instruction)) End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case
##

Ill-formed case instruction.
At this point, the analysed expression is expected, followed by the
keyword 'of'.

interactive_expr: Begin UIdent With
##
## Ends in an error in state: 395.
##
## module_path(And) -> UIdent . DOT module_path(And) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(And) -> UIdent . DOT And [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(Or) -> UIdent . DOT module_path(Or) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(Or) -> UIdent . DOT Or [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(field_path) -> UIdent . DOT module_path(field_path) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(field_path) -> UIdent . DOT field_path [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a value from a module.
At this point, the selection symbol '.' is expected, followed by either
  * the qualified name of a value, like 'A.B.c.2.d';
  * a value name.

interactive_expr: Begin For Ident ARROW Ident In With
##
## Ends in an error in state: 544.
##
## for_in -> For Ident ARROW Ident In . Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident In
##

Ill-formed iteration over a map.
At this point, the keyword 'map' is expected.

interactive_expr: Begin For Ident ARROW Ident In Map With
##
## Ends in an error in state: 545.
##
## for_in -> For Ident ARROW Ident In Map . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident In Map
##

Ill-formed iteration over a map.
At this point, a map is expected as an expression.

interactive_expr: Begin For Ident ARROW Ident With
##
## Ends in an error in state: 543.
##
## for_in -> For Ident ARROW Ident . In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident
##

Ill-formed iteration over a map.
At this point, the keywords 'in map' are expected, followed by the map
as an expression.

interactive_expr: Begin For Ident ARROW With
##
## Ends in an error in state: 542.
##
## for_in -> For Ident ARROW . Ident In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW
##

Ill-formed iteration over a map.
At this point, a variable denoting values in a map binding (as opposed
to keys) is expected.

interactive_expr: Begin For Ident ASS Verbatim To Verbatim Step Verbatim Attr
##
## Ends in an error in state: 539.
##
## for_int -> For Ident ASS expr To expr step_clause . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To expr step_clause
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 538, spurious reduction of production step_clause -> Step expr
##

Ill-formed iteration over a numerical interval.
At this point, if the step clause is complete, the loop body is
expected as a block of statements.
Note: A block is either delimited by '{' and '}' (terse dialect) or
'begin' and 'end' (verbose dialect).

interactive_expr: Begin For Ident ASS Verbatim To Verbatim Step With
##
## Ends in an error in state: 537.
##
## step_clause -> Step . expr [ LBRACE Block Begin ]
##
## The known suffix of the stack is as follows:
## Step
##

Ill-formed iteration over a numerical interval.
At this point, the index increment is expected as an expression.

interactive_expr: Begin For Ident ASS Verbatim To With
##
## Ends in an error in state: 535.
##
## for_int -> For Ident ASS expr To . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS expr To . expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To
##

Ill-formed iteration over a numerical interval.
At this point, the final value of the index is expected as an
expression.

interactive_expr: Begin For Ident ASS With
##
## Ends in an error in state: 533.
##
## for_int -> For Ident ASS . expr To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS . expr To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS
##

Ill-formed iteration over a numerical interval.
At this point, the expression for the initial value of the index is
expected.

interactive_expr: Begin For Ident In List UIdent While
##
## Ends in an error in state: 531.
##
## for_in -> For Ident In List expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In List expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed iteration over a list.
At this point, if the list is complete, the body of the loop is
expected as a block of statements (instructions and declarations).

interactive_expr: Begin For Ident ARROW Ident In Map UIdent While
##
## Ends in an error in state: 546.
##
## for_in -> For Ident ARROW Ident In Map expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident In Map expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed iteration over a map.
At this point, if the map is complete, the body of the loop is
expected as a block of statements (instructions and declarations).

interactive_expr: Begin For Ident In Set UIdent While
##
## Ends in an error in state: 528.
##
## for_in -> For Ident In Set expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In Set expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed iteration over a set.
At this point, if the set is complete, the loop body is expected as a
block of statements (instructions and declarations).

interactive_expr: Begin For Ident In List With
##
## Ends in an error in state: 530.
##
## for_in -> For Ident In List . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In List
##

Ill-formed iteration over a list.
At this point, the list is expected as an expression.

interactive_expr: Begin For Ident In Set With
##
## Ends in an error in state: 527.
##
## for_in -> For Ident In Set . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In Set
##

Ill-formed iteration over a set.
At this point, the set is expected as an expression.

interactive_expr: Begin For Ident In With
##
## Ends in an error in state: 526.
##
## for_in -> For Ident In . Set expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For Ident In . List expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In
##

Ill-formed iteration over a set or a list.
At this point, the keyword 'set' or 'list' is expected.

interactive_expr: Begin For Ident With
##
## Ends in an error in state: 525.
##
## for_in -> For Ident . ARROW Ident In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For Ident . In Set expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For Ident . In List expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident . ASS expr To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident . ASS expr To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident
##

Ill-formed iteration.
At this point, one of the following is expected:
  * the assignment symbol ':=' if iterating over a numerical interval;
  * the keyword 'in' if iterating over a list or a set;
  * a binding arrow '->' if iterating over a map.

interactive_expr: Begin For With
##
## Ends in an error in state: 524.
##
## for_in -> For . Ident ARROW Ident In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For . Ident In Set expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For . Ident In List expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For . Ident ASS expr To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For . Ident ASS expr To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For
##

Ill-formed iteration.
At this point, one of the following is expected:
  * a variable denoting the index, if iterating over a numerical
    interval;
  * a variable denoting an element, if iterating over a list or a set;
  * a variable denoting the key of a map, if iterating over a map.

interactive_expr: Begin Ident ASS With
##
## Ends in an error in state: 567.
##
## assignment(expr) -> lhs ASS . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## lhs ASS
##
interactive_expr: Begin If UIdent Then Ident ASS With
##
## Ends in an error in state: 604.
##
## assignment(closed_expr) -> lhs ASS . closed_expr [ Else ]
## assignment(expr) -> lhs ASS . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## lhs ASS
##

Ill-formed assignment.
At this point, the right-hand side is expected as an expression.

interactive_expr: Begin Ident With
##
## Ends in an error in state: 566.
##
## assignment(expr) -> lhs . ASS expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production field_path -> Ident
## In state 327, spurious reduction of production local_path -> field_path
## In state 320, spurious reduction of production path_expr -> local_path
## In state 559, spurious reduction of production lhs -> path_expr
##
interactive_expr: Begin If UIdent Then Ident With
##
## Ends in an error in state: 603.
##
## assignment(closed_expr) -> lhs . ASS closed_expr [ Else ]
## assignment(expr) -> lhs . ASS expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production field_path -> Ident
## In state 327, spurious reduction of production local_path -> field_path
## In state 320, spurious reduction of production path_expr -> local_path
## In state 559, spurious reduction of production lhs -> path_expr
##

Ill-formed assignment.
At this point, if the left-hand side is complete, the assignment
symbol ':=' is expected, followed by an expression.

interactive_expr: Begin If Verbatim Then Skip Else With
##
## Ends in an error in state: 616.
##
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) Else . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr) Else
##
interactive_expr: Begin If UIdent Then If UIdent Then Skip Else With
##
## Ends in an error in state: 598.
##
## if_then_else_instr(closed_instr) -> If expr Then test_clause(closed_instr) Else . test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) Else . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr) Else
##

Ill-formed conditional instruction.
At this point, the 'else' branch is expected as either
  * a single instruction;
  * a block of statements (instructions and declarations).
Note: A block, in this context, is either delimited by '{' and '}'
(terse dialect) or 'begin' and 'end' (verbose dialect).

interactive_expr: Begin If Verbatim Then Skip With
##
## Ends in an error in state: 615.
##
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) . Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 485, spurious reduction of production base_instr(closed_instr,closed_expr) -> Skip
## In state 613, spurious reduction of production closed_instr -> base_instr(closed_instr,closed_expr)
## In state 609, spurious reduction of production test_clause(closed_instr) -> closed_instr
##
interactive_expr: Begin If UIdent Then If UIdent Then Skip With
##
## Ends in an error in state: 597.
##
## if_then_else_instr(closed_instr) -> If expr Then test_clause(closed_instr) . Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) . Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 485, spurious reduction of production base_instr(closed_instr,closed_expr) -> Skip
## In state 613, spurious reduction of production closed_instr -> base_instr(closed_instr,closed_expr)
## In state 609, spurious reduction of production test_clause(closed_instr) -> closed_instr
##

Ill-formed conditional instruction.
At this point, if the 'then' branch is complete, the keyword 'else' is
expected, followed by either
  * a single instruction;
  * a block of statements (instructions and declarations).
Note: A block, in this context, is either delimited by '{' and '}'
(terse dialect) or 'begin' and 'end' (verbose dialect).

interactive_expr: Begin If Verbatim Then With
##
## Ends in an error in state: 484.
##
## if_then_else_instr(instruction) -> If expr Then . test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If expr Then . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin If UIdent Then If UIdent Then With
##
## Ends in an error in state: 523.
##
## if_then_else_instr(closed_instr) -> If expr Then . test_clause(closed_instr) Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr Then . test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If expr Then . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

Ill-formed conditional instruction.
At this point, the 'then' branch is expected as either
  * a single instruction;
  * a block of statements (instructions and declarations).
Note: A block, in this context, is either delimited by '{' and '}'
(terse dialect) or 'begin' and 'end' (verbose dialect).

interactive_expr: Begin If With
##
## Ends in an error in state: 482.
##
## if_then_else_instr(instruction) -> If . expr Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If . expr Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If UIdent Then If With
##
## Ends in an error in state: 521.
##
## if_then_else_instr(closed_instr) -> If . expr Then test_clause(closed_instr) Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If . expr Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If . expr Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional instruction.
At this point, the condition is expected as a Boolean expression.

interactive_expr: If With
##
## Ends in an error in state: 172.
##
## if_then_else_expr(expr) -> If . expr Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If . expr Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If UIdent Then If With
##
## Ends in an error in state: 489.
##
## if_then_else_expr(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
## if_then_else_expr(expr) -> If . expr Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If . expr Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional expression.
At this point, the condition is expected as a Boolean expression.

interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 149.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## selection DOT
##
interactive_expr: Ident DOT With
##
## Ends in an error in state: 145.
##
## field_path -> Ident DOT . nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##
interactive_expr: LPAR UIdent RPAR DOT With
##
## Ends in an error in state: 215.
##
## local_path -> par(expr) DOT . nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## par(expr) DOT
##

Ill-formed selection in a record or a tuple.
At this point, one of the following is expected:
  * a record field name, if selecting from a record;
  * the index of a tuple component, '0' denoting the first component.

interactive_expr: Begin Patch Ident While
##
## Ends in an error in state: 409.
##
## patch_instr(expr) -> Patch core_expr . With expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch core_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production field_path -> Ident
## In state 327, spurious reduction of production local_path -> field_path
## In state 320, spurious reduction of production path_expr -> local_path
## In state 207, spurious reduction of production core_expr -> path_expr
##
interactive_expr: Begin If UIdent Then Patch UIdent While
##
## Ends in an error in state: 518.
##
## patch_instr(closed_expr) -> Patch core_expr . With closed_expr [ Else ]
## patch_instr(expr) -> Patch core_expr . With expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch core_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
##

Ill-formed patch instruction.
At this point, if data structure to be patched is complete, the
keyword 'with' is expected.

interactive_expr: Record With
##
## Ends in an error in state: 141.
##
## terse_inj(Record,field_path_assignment) -> Record . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Record,field_path_assignment) -> Record . LBRACKET sep_or_term_list(field_path_assignment,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Record,field_path_assignment) -> Record . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Record,field_path_assignment) -> Record . sep_or_term_list(field_path_assignment,SEMI) End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed record expression.
At this point, one of the following is expected:
  * assignments to record fields, separated by semicolons ';';
  * an opening bracket '[' followed by a field assignment;
  * brackets '[]' or the keyword 'end' if defining an empty record.

interactive_expr: Begin If UIdent Then Patch UIdent With With
##
## Ends in an error in state: 519.
##
## patch_instr(closed_expr) -> Patch core_expr With . closed_expr [ Else ]
## patch_instr(expr) -> Patch core_expr With . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch core_expr With
##
interactive_expr: Begin Patch Ident With With
##
## Ends in an error in state: 410.
##
## patch_instr(expr) -> Patch core_expr With . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch core_expr With
##

Ill-formed patch instruction.
At this point, the patch is expected as an expression.

interactive_expr: Begin If UIdent Then Patch With
##
## Ends in an error in state: 517.
##
## patch_instr(closed_expr) -> Patch . core_expr With closed_expr [ Else ]
## patch_instr(expr) -> Patch . core_expr With expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch
##
interactive_expr: Begin Patch With
##
## Ends in an error in state: 408.
##
## patch_instr(expr) -> Patch . core_expr With expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch
##

Ill-formed patch instruction.
At this point, the patched data structure (e.g. a record, set or map)
is expected as an expression.

interactive_expr: Begin Remove Verbatim From With
##
## Ends in an error in state: 406.
##
## remove_instr(expr) -> Remove expr From . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From
##
interactive_expr: Begin If UIdent Then Remove UIdent From With
##
## Ends in an error in state: 488.
##
## remove_instr(closed_expr) -> Remove expr From . closed_expr [ Else ]
## remove_instr(expr) -> Remove expr From . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From
##

Ill-formed removal from a collection.
At this point, the keyword 'map', 'big_map', or 'set' is expected.

interactive_expr: Begin Remove With
##
## Ends in an error in state: 404.
##
## remove_instr(expr) -> Remove . expr From expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove
##
interactive_expr: Begin If UIdent Then Remove With
##
## Ends in an error in state: 486.
##
## remove_instr(closed_expr) -> Remove . expr From closed_expr [ Else ]
## remove_instr(expr) -> Remove . expr From expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove
##

Ill-formed removal from a collection.
At this point, one of the following is expected:
  * a set element as an expression, if removing from a set;
  * a key as an expression, if removing from a map or big map.

interactive_expr: Begin Skip End While
##
## Ends in an error in state: 389.
##
## block_with(expr) -> block . With expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block
##

Ill-formed block expression.
At this point, the keyword 'with' is expected, followed by an
expression whose value is that of the whole block.

interactive_expr: Begin Skip End With With
##
## Ends in an error in state: 390.
##
## block_with(expr) -> block With . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block With
##
interactive_expr: If UIdent Then LBRACE Skip RBRACE With With
##
## Ends in an error in state: 503.
##
## block_with(closed_expr) -> block With . closed_expr [ Else ]
## block_with(expr) -> block With . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block With
##

Ill-formed block expression.
At this point, an expression is expected, whose value is that of the
block.

interactive_expr: Begin Skip With
##
## Ends in an error in state: 632.
##
## verb_block -> Begin sep_or_term_list(statement,SEMI) . End [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Begin sep_or_term_list(statement,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 618, spurious reduction of production nsepseq(statement,SEMI) -> statement
## In state 627, spurious reduction of production sep_or_term_list(statement,SEMI) -> nsepseq(statement,SEMI)
##

Ill-formed block of statements.
At this point, if the statement is complete, one of the following is
expected:
  * a semicolon ';' followed by another statement (instruction or
    declaration);
  * the keyword 'end' if the block is complete.

interactive_expr: Begin Var Ident ASS With
##
## Ends in an error in state: 393.
##
## unqualified_decl(ASS) -> core_pattern ASS . expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern ASS
##
interactive_expr: Begin Var Ident COLON WILD ASS With
##
## Ends in an error in state: 310.
##
## unqualified_decl(ASS) -> core_pattern COLON type_expr ASS . expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON type_expr ASS
##

Ill-formed variable declaration.
At this point, an expression is expected, whose value is the initial
value of the variable being defined.

interactive_expr: Begin Var Ident COLON UIdent ARROW
##
## Ends in an error in state: 309.
##
## unqualified_decl(ASS) -> core_pattern COLON type_expr . ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 17, spurious reduction of production variant -> UIdent
## In state 40, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 53, spurious reduction of production type_expr -> sum_type
##

Ill-formed variable declaration.
At this point, if the type is complete, the assignment symbol ':=' is
expected, followed by the expression whose value is the initial value
of the variable being defined.

interactive_expr: Begin Var Ident With
##
## Ends in an error in state: 307.
##
## unqualified_decl(ASS) -> core_pattern . ASS expr [ SEMI RBRACE End ]
## unqualified_decl(ASS) -> core_pattern . COLON type_expr ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern
##

Ill-formed variable declaration.
At this point, one of the following is expected:
  * a colon ':' followed by the type of the variable;
  * the assignment symbol ':=' followed by an expression whose
    value is the initial value of the variable being defined.

interactive_expr: Begin Var With
##
## Ends in an error in state: 220.
##
## var_decl -> Var . unqualified_decl(ASS) [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## Var
##

Ill-formed variable declaration.
At this point, a pattern is expected, e.g. a variable.

interactive_expr: Begin While With
##
## Ends in an error in state: 183.
##
## while_loop -> While . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## While
##

Ill-formed general loop.
At this point, the condition is expected as a Boolean expression.

interactive_expr: BigMap LBRACKET With
##
## Ends in an error in state: 180.
##
## terse_inj(BigMap,binding) -> BigMap LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(BigMap,binding) -> BigMap LBRACKET . sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap LBRACKET
##

Ill-formed big map expression.
At this point, one of the following is expected:
  * key/value bindings separated by semicolons ';';
  * a closing bracket ']' if the big map is empty.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: BigMap With
##
## Ends in an error in state: 179.
##
## terse_inj(BigMap,binding) -> BigMap . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(BigMap,binding) -> BigMap . LBRACKET sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(BigMap,binding) -> BigMap . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(BigMap,binding) -> BigMap . sep_or_term_list(binding,SEMI) End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap
##

Ill-formed big map expression.
At this point, one of the following is expected:
  * key/value bindings separated by semicolons ';';
  * an opening bracket '[' followed by a binding;
  * brackets '[]' or the keyword 'end' if the big map is empty.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Block LBRACE Skip With
##
## Ends in an error in state: 624.
##
## terse_block -> option(Block) LBRACE sep_or_term_list(statement,SEMI) . RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## option(Block) LBRACE sep_or_term_list(statement,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 618, spurious reduction of production nsepseq(statement,SEMI) -> statement
## In state 627, spurious reduction of production sep_or_term_list(statement,SEMI) -> nsepseq(statement,SEMI)
##

Ill-formed block of statements.
At this point, if the statement is complete, one of the following is
expected:
  * a semicolon ';' followed by another statement;
  * a closing brace '}' if there are no more statements.
Note: A statement is either an instruction or a declaration.

interactive_expr: Block With
##
## Ends in an error in state: 218.
##
## terse_block -> option(Block) . LBRACE sep_or_term_list(statement,SEMI) RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## option(Block)
##

Ill-formed block of statements.
At this point, an opening brace '{' is expected, followed by a
statement (instruction or declaration).
Note: A statement is either an instruction or a declaration.

interactive_expr: Case Verbatim Of LBRACKET With
##
## Ends in an error in state: 660.
##
## terse_case(expr) -> Case expr Of LBRACKET . cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## terse_case(expr) -> Case expr Of LBRACKET . VBAR cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET
##

Ill-formed case expression.
At this point, one of the following is expected:
  * a clause made of a pattern and an expression separated by an arrow
    '->';
  * a vertical bar '|' followed by a clause.

interactive_expr: Case Verbatim Of With
##
## Ends in an error in state: 649.
##
## terse_case(expr) -> Case expr Of . LBRACKET cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## terse_case(expr) -> Case expr Of . LBRACKET VBAR cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## verb_case(expr) -> Case expr Of . cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## verb_case(expr) -> Case expr Of . VBAR cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of
##

Ill-formed case expression.
At this point, one of the following is expected:
  * a clause made of a pattern and an expression separated by an arrow
    '->';
  * a vertical bar '|' followed by a clause;
  * an opening bracket '[' followed by one of the above.

interactive_expr: Case Verbatim Of WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 658.
##
## nsepseq(case_clause(expr),VBAR) -> case_clause(expr) VBAR . nsepseq(case_clause(expr),VBAR) [ RBRACKET End ]
##
## The known suffix of the stack is as follows:
## case_clause(expr) VBAR
##
interactive_expr: Case UIdent Of VBAR With
##
## Ends in an error in state: 650.
##
## verb_case(expr) -> Case expr Of VBAR . cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of VBAR
##
interactive_expr: Case UIdent Of LBRACKET VBAR With
##
## Ends in an error in state: 661.
##
## terse_case(expr) -> Case expr Of LBRACKET VBAR . cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET VBAR
##

Ill-formed case expression.
At this point, a clause is expected, made of a pattern and an
expression separated by an arrow '->'.

interactive_expr: Case Verbatim Of LPAR WILD SHARP Bytes With
##
## Ends in an error in state: 247.
##
## par(pattern) -> LPAR pattern . RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## tuple(pattern) -> pattern . COMMA nsepseq(pattern,COMMA) [ RPAR ]
## typed_pattern -> pattern . COLON type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 264, spurious reduction of production nsepseq(core_pattern,SHARP) -> core_pattern
## In state 263, spurious reduction of production pattern -> core_pattern SHARP nsepseq(core_pattern,SHARP)
##

Ill-formed parenthesised/tuple/typed pattern.
At this point, if the pattern is complete, one of the following is
expected:
  * a closing parenthesis ')' if defining a parenthesised pattern;
  * a comma ',' followed by a component as a pattern, if defining a
    tuple;
  * a type annotation starting with a colon ':' if defining a typed
    pattern.

interactive_expr: Case Verbatim Of LPAR With
##
## Ends in an error in state: 233.
##
## par(pattern) -> LPAR . pattern RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## par(tuple(pattern)) -> LPAR . tuple(pattern) RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## par(typed_pattern) -> LPAR . typed_pattern RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised/tuple/typed pattern.
At this point, a pattern is expected.

interactive_expr: Case Verbatim Of LPAR WILD COMMA With
##
## Ends in an error in state: 249.
##
## tuple(pattern) -> pattern COMMA . nsepseq(pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern COMMA
##

Ill-formed tuple pattern.
At this point, a tuple component is expected as a pattern.

interactive_expr: Case Verbatim Of List LBRACKET WILD With
##
## Ends in an error in state: 272.
##
## terse_inj(List,core_pattern) -> List LBRACKET sep_or_term_list(core_pattern,SEMI) . RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET sep_or_term_list(core_pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 276, spurious reduction of production nsepseq(core_pattern,SEMI) -> core_pattern
## In state 275, spurious reduction of production sep_or_term_list(core_pattern,SEMI) -> nsepseq(core_pattern,SEMI)
##

Ill-formed list pattern.
At this point, if the element is complete, one of the following
is expected:
  * a semicolon ';' followed by another element as a pattern;
  * a closing bracket ']' if the list is complete.

interactive_expr: Case Verbatim Of List LBRACKET With
##
## Ends in an error in state: 270.
##
## terse_inj(List,core_pattern) -> List LBRACKET . RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## terse_inj(List,core_pattern) -> List LBRACKET . sep_or_term_list(core_pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET
##

Ill-formed list pattern.
At this point, one of the following is expected:
  * elements as patterns separated by semicolons ';';
  * a closing bracket ']' if the list is empty.

interactive_expr: Case Verbatim Of List With
##
## Ends in an error in state: 232.
##
## terse_inj(List,core_pattern) -> List . LBRACKET RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## terse_inj(List,core_pattern) -> List . LBRACKET sep_or_term_list(core_pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## verb_inj(List,core_pattern) -> List . End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## verb_inj(List,core_pattern) -> List . sep_or_term_list(core_pattern,SEMI) End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List
##

Ill-formed list pattern.
At this point, one of the following is expected:
  * elements as patterns separated by semicolons ';';
  * an opening bracket '[' followed by an element as a pattern;
  * brackets '[]' or the keyword 'end' if the list is empty.

interactive_expr: Case Verbatim Of WILD ARROW With
##
## Ends in an error in state: 652.
##
## case_clause(expr) -> pattern ARROW . expr [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

Ill-formed clause of a case expression.
At this point, the right-hand side of the clause is expected as an
expression.

interactive_expr: Case Verbatim Of WILD SHARP WILD SHARP With
##
## Ends in an error in state: 265.
##
## nsepseq(core_pattern,SHARP) -> core_pattern SHARP . nsepseq(core_pattern,SHARP) [ RPAR COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern SHARP
##
interactive_expr: Case Verbatim Of WILD SHARP With
##
## Ends in an error in state: 262.
##
## pattern -> core_pattern SHARP . nsepseq(core_pattern,SHARP) [ RPAR COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern SHARP
##

Ill-formed list pattern.
At this point, a non-empty list is expected as a pattern.

interactive_expr: Case Verbatim Of WILD With
##
## Ends in an error in state: 651.
##
## case_clause(expr) -> pattern . ARROW expr [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 261, spurious reduction of production pattern -> core_pattern
##

Ill-formed clause of a case expression.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by the right-hand side of the clause as an expression.

interactive_expr: Case With
##
## Ends in an error in state: 176.
##
## terse_case(expr) -> Case . expr Of LBRACKET cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## terse_case(expr) -> Case . expr Of LBRACKET VBAR cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## verb_case(expr) -> Case . expr Of cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## verb_case(expr) -> Case . expr Of VBAR cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case
##

Ill-formed case expression.
At this point, the analysed expression is expected.

interactive_expr: If UIdent Then Function LPAR Const Ident RPAR COLON UIdent ARROW
##
## Ends in an error in state: 507.
##
## fun_expr(closed_expr) -> Function parameters COLON type_expr . Is closed_expr [ Else ]
## fun_expr(expr) -> Function parameters COLON type_expr . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 17, spurious reduction of production variant -> UIdent
## In state 40, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 53, spurious reduction of production type_expr -> sum_type
##
interactive_expr: Function LPAR Const Ident RPAR COLON UIdent ARROW
##
## Ends in an error in state: 669.
##
## fun_expr(expr) -> Function parameters COLON type_expr . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 17, spurious reduction of production variant -> UIdent
## In state 40, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 53, spurious reduction of production type_expr -> sum_type
##

Ill-formed function expression.
At this point, if the return type is complete, the keyword 'is' is
expected, followed by the body as an expression.

interactive_expr: Function LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 175.
##
## fun_expr(expr) -> Function parameters Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters Is
##
interactive_expr: If UIdent Then Function LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 494.
##
## fun_expr(closed_expr) -> Function parameters Is . closed_expr [ Else ]
## fun_expr(expr) -> Function parameters Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters Is
##
interactive_expr: If UIdent Then Function LPAR Const Ident RPAR COLON Ident Is With
##
## Ends in an error in state: 508.
##
## fun_expr(closed_expr) -> Function parameters COLON type_expr Is . closed_expr [ Else ]
## fun_expr(expr) -> Function parameters COLON type_expr Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON type_expr Is
##
interactive_expr: Function LPAR Const Ident RPAR COLON WILD Is With
##
## Ends in an error in state: 670.
##
## fun_expr(expr) -> Function parameters COLON type_expr Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON type_expr Is
##

Ill-formed function expression.
At this point, the body is expected as an expression.

interactive_expr: If UIdent Then Function LPAR Const Ident RPAR With
##
## Ends in an error in state: 493.
##
## fun_expr(closed_expr) -> Function parameters . Is closed_expr [ Else ]
## fun_expr(closed_expr) -> Function parameters . COLON type_expr Is closed_expr [ Else ]
## fun_expr(expr) -> Function parameters . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function parameters . COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters
##
interactive_expr: Function LPAR Const Ident RPAR With
##
## Ends in an error in state: 174.
##
## fun_expr(expr) -> Function parameters . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function parameters . COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters
##

Ill-formed function expression.
At this point, one of the following is expected:
  * a colon ':' followed by the return type;
  * the keyword 'is' followed by the function body as an expression.

contract: Attr Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 455.
##
## fun_decl -> nseq(Attr) Function Ident parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Function Ident parameters . COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function Ident parameters
##

Ill-formed function declaration.
At this point, one of the following is expected:
  * a colon ':' followed by the return type;
  * the keyword 'is' followed by the function body as an expression.

interactive_expr: Function LPAR Const Ident With
##
## Ends in an error in state: 123.
##
## param_decl -> param_kind var_pattern . [ SEMI RPAR ]
## param_decl -> param_kind var_pattern . param_type [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## param_kind var_pattern
##

Ill-formed function parameter declaration.
At this point, one of the following is expected:
  * a colon ':' followed by the type of the parameter;
  * a semicolon ';' followed with another parameter declaration;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: Function LPAR Var Ident COLON String With
##
## Ends in an error in state: 132.
##
## par(nsepseq(param_decl,SEMI)) -> LPAR nsepseq(param_decl,SEMI) . RPAR [ Is COLON ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(param_decl,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 70, spurious reduction of production cartesian_level -> core_type
## In state 77, spurious reduction of production fun_type_level -> cartesian_level
## In state 125, spurious reduction of production param_type -> COLON fun_type_level
## In state 126, spurious reduction of production param_decl -> param_kind var_pattern param_type
## In state 129, spurious reduction of production nsepseq(param_decl,SEMI) -> param_decl
##

Ill-formed function parameter declaration.
At this point, if the parameter declaration is complete, one of the
following is expected:
  * a semicolon ';' followed by another parameter declaration;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: Function LPAR Var Ident COLON With
##
## Ends in an error in state: 124.
##
## param_type -> COLON . fun_type_level [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed function parameter declaration.
At this point, the type of the parameter is expected.
Note: Use parentheses if you want a sum type.

interactive_expr: Function LPAR Var Ident SEMI With
##
## Ends in an error in state: 130.
##
## nsepseq(param_decl,SEMI) -> param_decl SEMI . nsepseq(param_decl,SEMI) [ RPAR ]
##
## The known suffix of the stack is as follows:
## param_decl SEMI
##
interactive_expr: Function LPAR With
##
## Ends in an error in state: 117.
##
## par(nsepseq(param_decl,SEMI)) -> LPAR . nsepseq(param_decl,SEMI) RPAR [ Is COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function parameter declaration.
At this point, one of the following is expected:
  * the keyword 'const' if the parameter is constant in the body;
  * the keyword 'var' if the parameter is variable in the body.

interactive_expr: Function LPAR Var With
##
## Ends in an error in state: 120.
##
## param_decl -> param_kind . var_pattern [ SEMI RPAR ]
## param_decl -> param_kind . var_pattern param_type [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## param_kind
##

Ill-formed function parameter declaration.
At this point, one of the following is expected:
  * attributes for the parameter;
  * the parameter as a variable.

contract: Function With
##
## Ends in an error in state: 419.
##
## fun_decl -> Function . Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function . Ident parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function
##
contract: Recursive Function With
##
## Ends in an error in state: 115.
##
## fun_decl -> Recursive Function . Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function . Ident parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function
##
contract: Attr Function With
##
## Ends in an error in state: 453.
##
## fun_decl -> nseq(Attr) Function . Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Function . Ident parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function
##
contract: Attr Recursive Function With
##
## Ends in an error in state: 444.
##
## fun_decl -> nseq(Attr) Recursive Function . Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Recursive Function . Ident parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function
##

Ill-formed function declaration.
At this point, the name of the function is expected.

interactive_expr: Ident LBRACKET With
##
## Ends in an error in state: 208.
##
## brackets(expr) -> LBRACKET . expr RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed map lookup.
At this point, a key is expected as an expression.

interactive_expr: Ident LPAR Verbatim COMMA With
##
## Ends in an error in state: 683.
##
## nsepseq(expr,COMMA) -> expr COMMA . nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##
interactive_expr: Ident LPAR With
##
## Ends in an error in state: 138.
##
## par(nsepseq(expr,COMMA)) -> LPAR . nsepseq(expr,COMMA) RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function call.
At this point, an argument is expected as an expression.

interactive_expr: Ident While
##
## Ends in an error in state: 741.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production field_path -> Ident
## In state 327, spurious reduction of production local_path -> field_path
## In state 320, spurious reduction of production path_expr -> local_path
## In state 207, spurious reduction of production core_expr -> path_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed expression.
At this point, if the expression is complete, the end of the file is
expected.

interactive_expr: Ident With With
##
## Ends in an error in state: 331.
##
## update -> core_expr With . core_expr [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## core_expr With
##

Ill-formed record update.
At this point, a record is expected, starting with the keyword
'record'.

interactive_expr: If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 674.
##
## if_then_else_expr(expr) -> If expr Then closed_expr Else . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 513.
##
## if_then_else_expr(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
## if_then_else_expr(expr) -> If expr Then closed_expr Else . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##

Ill-formed conditional expression.
At this point, the contents of the 'else' branch is expected as an
expression.

interactive_expr: If Verbatim Then With
##
## Ends in an error in state: 672.
##
## if_then_else_expr(expr) -> If expr Then . closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If expr Then . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If UIdent Then If UIdent Then With
##
## Ends in an error in state: 491.
##
## if_then_else_expr(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
## if_then_else_expr(expr) -> If expr Then . closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If expr Then . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

Ill-formed conditional expression.
At this point, the contents of the 'then' branch is expected as an
expression.

interactive_expr: LPAR Verbatim COLON Ident With
##
## Ends in an error in state: 675.
##
## par(typed_expr) -> LPAR typed_expr . RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR typed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production type_name_expr -> Ident
## In state 46, spurious reduction of production core_type -> type_name_expr
## In state 70, spurious reduction of production cartesian_level -> core_type
## In state 77, spurious reduction of production fun_type_level -> cartesian_level
## In state 69, spurious reduction of production type_expr -> fun_type_level
## In state 687, spurious reduction of production typed_expr -> disj_expr_level COLON type_expr
##

Ill-formed typed expression.
At this point, if the type is complete, a closing parenthesis ')' is
expected.

interactive_expr: LPAR Verbatim COMMA With
##
## Ends in an error in state: 680.
##
## tuple(expr) -> expr COMMA . nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Ill-formed tuple expression.
At this point, a tuple component is expected as an expression.

interactive_expr: LPAR With
##
## Ends in an error in state: 170.
##
## par(expr) -> LPAR . expr RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive DOT Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## par(tuple(expr)) -> LPAR . tuple(expr) RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## par(typed_expr) -> LPAR . typed_expr RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised/tuple/typed expression.
At this point, an expression is expected.

interactive_expr: Lang With
##
## Ends in an error in state: 169.
##
## code_inj -> Lang . expr RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Lang
##

Ill-formed code injection.
At this point, an expression is expected, whose value is a verbatim
string containing the code to inject.

interactive_expr: List LBRACKET With
##
## Ends in an error in state: 690.
##
## terse_inj(List,expr) -> List LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(List,expr) -> List LBRACKET . sep_or_term_list(expr,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET
##

Ill-formed list expression.
At this point, one of the following is expected:
  * elements as expressions separated by semicolons ';';
  * a closing bracket ']' if the list is empty.

interactive_expr: List With
##
## Ends in an error in state: 168.
##
## terse_inj(List,expr) -> List . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(List,expr) -> List . LBRACKET sep_or_term_list(expr,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(List,expr) -> List . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(List,expr) -> List . sep_or_term_list(expr,SEMI) End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## List
##

Ill-formed list expression.
At this point, one of the following is expected:
  * elements as expressions separated by semicolons ';';
  * an opening bracket '[' followed by an element;
  * the brackets '[]' or the keyword 'end' if the list is empty.

contract: Const Record Ident EQ With
##
## Ends in an error in state: 229.
##
## field_pattern -> Ident EQ . core_pattern [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed record pattern.
At this point, the right-hand side of the field assignment is expected
as a pattern.

contract: Const Record Ident With
##
## Ends in an error in state: 293.
##
## verb_inj(Record,field_pattern) -> Record sep_or_term_list(field_pattern,SEMI) . End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record sep_or_term_list(field_pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 228, spurious reduction of production field_pattern -> Ident
## In state 288, spurious reduction of production nsepseq(field_pattern,SEMI) -> field_pattern
## In state 287, spurious reduction of production sep_or_term_list(field_pattern,SEMI) -> nsepseq(field_pattern,SEMI)
##

Ill-formed record constant declaration.
At this point, if the field pattern is complete, one of the
following is expected:
  * a semicolon ';' followed by another field pattern;
  * the keyword 'end' if the record is complete.

contract: Const Record LBRACKET Ident EQ Bytes End
##
## Ends in an error in state: 284.
##
## terse_inj(Record,field_pattern) -> Record LBRACKET sep_or_term_list(field_pattern,SEMI) . RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 288, spurious reduction of production nsepseq(field_pattern,SEMI) -> field_pattern
## In state 287, spurious reduction of production sep_or_term_list(field_pattern,SEMI) -> nsepseq(field_pattern,SEMI)
##

Ill-formed record pattern.
At this point, if the field pattern is complete, one of the following
is expected:
  * a semicolon ';' followed by another field pattern;
  * a closing bracket ']' if the record is complete.

contract: Const Record LBRACKET With
##
## Ends in an error in state: 226.
##
## terse_inj(Record,field_pattern) -> Record LBRACKET . RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## terse_inj(Record,field_pattern) -> Record LBRACKET . sep_or_term_list(field_pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * field patterns separated by semicolons ';';
  * a closing bracket ']' if the record is empty.

contract: Const Record With
##
## Ends in an error in state: 224.
##
## terse_inj(Record,field_pattern) -> Record . LBRACKET RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## terse_inj(Record,field_pattern) -> Record . LBRACKET sep_or_term_list(field_pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## verb_inj(Record,field_pattern) -> Record . End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## verb_inj(Record,field_pattern) -> Record . sep_or_term_list(field_pattern,SEMI) End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * fields as patterns separated by semicolons ';';
  * an opening bracket '[', followed by a field pattern;
  * the brackets '[]' and keyword 'end', if the record is empty.

interactive_expr: MINUS With
##
## Ends in an error in state: 167.
##
## unary_op(MINUS,update_expr_level) -> MINUS . update_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Ill-formed unary expression.
At this point, an arithmetic expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Map LBRACKET With
##
## Ends in an error in state: 704.
##
## terse_inj(Map,binding) -> Map LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Map,binding) -> Map LBRACKET . sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Map LBRACKET
##

Ill-formed map expression.
At this point, one of the following is expected:
  * key/value bindings separated by semicolons ';';
  * a closing bracket ']' if the map is empty.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Map Verbatim ARROW With
##
## Ends in an error in state: 639.
##
## binding -> expr ARROW . expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## expr ARROW
##

Ill-formed key/value binding in a map.
At this point, the value is expected as an expression.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Map With
##
## Ends in an error in state: 166.
##
## terse_inj(Map,binding) -> Map . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Map,binding) -> Map . LBRACKET sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Map,binding) -> Map . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Map,binding) -> Map . sep_or_term_list(binding,SEMI) End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Map
##

Ill-formed map expression.
At this point, one of the following is expected:
  * key/value bindings separated by semicolons ';';
  * an opening bracket '[' followed by a binding;
  * brackets '[]' or the keyword 'end' if the map is empty;
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Not With
##
## Ends in an error in state: 162.
##
## unary_op(Not,update_expr_level) -> Not . update_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Not
##

Ill-formed unary expression.
At this point, a Boolean expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Record Ident EQ With
##
## Ends in an error in state: 161.
##
## field_path_assignment -> field_path EQ . expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## field_path EQ
##

Ill-formed record expression.
At this point, the field value is expected as an expression.

interactive_expr: Record LBRACKET With
##
## Ends in an error in state: 142.
##
## terse_inj(Record,field_path_assignment) -> Record LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Record,field_path_assignment) -> Record LBRACKET . sep_or_term_list(field_path_assignment,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record expression.
At this point, one of the following is expected:
  * field assignments separated by semicolons ';';
  * a closing bracket ']' if the record is empty.

interactive_expr: Set LBRACKET With
##
## Ends in an error in state: 716.
##
## terse_inj(Set,expr) -> Set LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Set,expr) -> Set LBRACKET . sep_or_term_list(expr,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Set LBRACKET
##

Ill-formed set expression.
At this point, one of the following is expected:
  * elements as expressions separated by semicolons ';';
  * a closing bracket ']' if the set is empty.

interactive_expr: Set With
##
## Ends in an error in state: 140.
##
## terse_inj(Set,expr) -> Set . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Set,expr) -> Set . LBRACKET sep_or_term_list(expr,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Set,expr) -> Set . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Set,expr) -> Set . sep_or_term_list(expr,SEMI) End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Set
##

Ill-formed set expression.
At this point, one of the following is expected:
  * elements as expressions separated by semicolons ';';
  * an opening bracket '[' followed by an element;
  * brackets '[]' or the keyword 'end' if the set is empty.

interactive_expr: Verbatim CARET With
##
## Ends in an error in state: 347.
##
## bin_op(cons_expr_level,CARET,cat_expr_level) -> cons_expr_level CARET . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## cons_expr_level CARET
##

Ill-formed string expression.
At this point, a string expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Verbatim SHARP With
##
## Ends in an error in state: 357.
##
## bin_op(add_expr_level,SHARP,cons_expr_level) -> add_expr_level SHARP . cons_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr_level SHARP
##

Ill-formed list expression.
At this point, a list is expected as an expression.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Verbatim Contains With
##
## Ends in an error in state: 193.
##
## set_mem_level -> update_expr_level Contains . set_mem_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Module LBRACE Function From End Else EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## update_expr_level Contains
##

Ill-formed membership test in a set.
At this point, a set element is expected as an expression.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Verbatim And With
##
## Ends in an error in state: 364.
##
## conj_expr_level -> conj_expr_level And . set_mem_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Module LBRACE Function From End Else EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## conj_expr_level And
##
interactive_expr: Verbatim Or With
##
## Ends in an error in state: 345.
##
## disj_expr_level -> disj_expr_level Or . conj_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Module LBRACE Function From End Else EOF Directive Const COMMA COLON Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## disj_expr_level Or
##

Ill-formed Boolean expression.
At this point, a Boolean expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Verbatim EQ With
##
## Ends in an error in state: 377.
##
## bin_op(comp_expr_level,EQ,cat_expr_level) -> comp_expr_level EQ . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ
##
interactive_expr: Verbatim NE With
##
## Ends in an error in state: 367.
##
## bin_op(comp_expr_level,NE,cat_expr_level) -> comp_expr_level NE . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##
interactive_expr: Verbatim GE With
##
## Ends in an error in state: 375.
##
## bin_op(comp_expr_level,GE,cat_expr_level) -> comp_expr_level GE . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GE
##
interactive_expr: Verbatim GT With
##
## Ends in an error in state: 373.
##
## bin_op(comp_expr_level,GT,cat_expr_level) -> comp_expr_level GT . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GT
##
interactive_expr: Verbatim LE With
##
## Ends in an error in state: 371.
##
## bin_op(comp_expr_level,LE,cat_expr_level) -> comp_expr_level LE . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##
interactive_expr: Verbatim LT With
##
## Ends in an error in state: 369.
##
## bin_op(comp_expr_level,LT,cat_expr_level) -> comp_expr_level LT . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##

Ill-formed comparison expression.
At this point, a comparable expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Verbatim MINUS With
##
## Ends in an error in state: 361.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ VBAR Type To Then Step SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##
interactive_expr: Verbatim Mod With
##
## Ends in an error in state: 338.
##
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level Mod . unary_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Mod
##
interactive_expr: Verbatim PLUS With
##
## Ends in an error in state: 359.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ VBAR Type To Then Step SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##
interactive_expr: Verbatim SLASH With
##
## Ends in an error in state: 336.
##
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level SLASH . unary_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##
interactive_expr: Verbatim TIMES With
##
## Ends in an error in state: 312.
##
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level TIMES . unary_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##

Ill-formed arithmetic expression.
At this point, an expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: With
##
## Ends in an error in state: 739.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed expression.
At this point, an expression is expected.

contract: Const Ident EQ With
##
## Ends in an error in state: 432.
##
## unqualified_decl(EQ) -> core_pattern EQ . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern EQ
##
contract: Const Ident COLON UIdent EQ With
##
## Ends in an error in state: 436.
##
## unqualified_decl(EQ) -> core_pattern COLON type_expr EQ . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON type_expr EQ
##

Ill-formed constant declaration.
At this point, an expression is expected, whose value is that of the
constant.

contract: Const Ident With
##
## Ends in an error in state: 431.
##
## unqualified_decl(EQ) -> core_pattern . EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## unqualified_decl(EQ) -> core_pattern . COLON type_expr EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern
##

Ill-formed constant declaration.
At this point, one of the following is expected:
  * a colon ':' followed by the type of the constant;
  * the definition symbol '=' followed by an expression whose value is
    that of the constant.

contract: Const With
##
## Ends in an error in state: 429.
##
## const_decl -> Const . unqualified_decl(EQ) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Const
##
contract: Attr Const With
##
## Ends in an error in state: 462.
##
## const_decl -> nseq(Attr) Const . unqualified_decl(EQ) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Const
##

Ill-formed constant declaration.
At this point, a pattern is expected, e.g. a variable.

contract: Function Ident LPAR Const Ident RPAR COLON UIdent Is With
##
## Ends in an error in state: 426.
##
## fun_decl -> Function Ident parameters COLON type_expr Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters COLON type_expr Is
##
contract: Attr Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 456.
##
## fun_decl -> nseq(Attr) Function Ident parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function Ident parameters Is
##
contract: Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 422.
##
## fun_decl -> Function Ident parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters Is
##
contract: Recursive Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 135.
##
## fun_decl -> Recursive Function Ident parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters Is
##
contract: Attr Recursive Function Ident LPAR Const Ident RPAR COLON UIdent Is With
##
## Ends in an error in state: 451.
##
## fun_decl -> nseq(Attr) Recursive Function Ident parameters COLON type_expr Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function Ident parameters COLON type_expr Is
##
contract: Attr Function Ident LPAR Const Ident RPAR COLON UIdent Is With
##
## Ends in an error in state: 460.
##
## fun_decl -> nseq(Attr) Function Ident parameters COLON type_expr Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function Ident parameters COLON type_expr Is
##
contract: Recursive Function Ident LPAR Const Ident RPAR COLON WILD Is With
##
## Ends in an error in state: 729.
##
## fun_decl -> Recursive Function Ident parameters COLON type_expr Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters COLON type_expr Is
##
contract: Attr Recursive Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 447.
##
## fun_decl -> nseq(Attr) Recursive Function Ident parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function Ident parameters Is
##

Ill-formed function declaration.
At this point, the function body is expected as an expression.

contract: Function Ident LPAR Const Ident RPAR COLON Ident With
##
## Ends in an error in state: 425.
##
## fun_decl -> Function Ident parameters COLON type_expr . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 32, spurious reduction of production type_name_expr -> Ident
## In state 46, spurious reduction of production core_type -> type_name_expr
## In state 70, spurious reduction of production cartesian_level -> core_type
## In state 77, spurious reduction of production fun_type_level -> cartesian_level
## In state 69, spurious reduction of production type_expr -> fun_type_level
##
contract: Recursive Function Ident LPAR Const Ident RPAR COLON String With
##
## Ends in an error in state: 728.
##
## fun_decl -> Recursive Function Ident parameters COLON type_expr . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 70, spurious reduction of production cartesian_level -> core_type
## In state 77, spurious reduction of production fun_type_level -> cartesian_level
## In state 69, spurious reduction of production type_expr -> fun_type_level
##
contract: Attr Recursive Function Ident LPAR Const Ident RPAR COLON UIdent With
##
## Ends in an error in state: 450.
##
## fun_decl -> nseq(Attr) Recursive Function Ident parameters COLON type_expr . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function Ident parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 17, spurious reduction of production variant -> UIdent
## In state 40, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 53, spurious reduction of production type_expr -> sum_type
##
contract: Attr Function Ident LPAR Const Ident RPAR COLON UIdent With
##
## Ends in an error in state: 459.
##
## fun_decl -> nseq(Attr) Function Ident parameters COLON type_expr . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function Ident parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 17, spurious reduction of production variant -> UIdent
## In state 40, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 53, spurious reduction of production type_expr -> sum_type
##

Ill-formed function declaration.
At this point, if the return type is complete, the keyword 'is' is
expected, followed by the function body as an expression.

contract: Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 421.
##
## fun_decl -> Function Ident parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function Ident parameters . COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters
##
contract: Recursive Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 134.
##
## fun_decl -> Recursive Function Ident parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function Ident parameters . COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters
##
contract: Attr Recursive Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 446.
##
## fun_decl -> nseq(Attr) Recursive Function Ident parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Recursive Function Ident parameters . COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function Ident parameters
##

Ill-formed function declaration.
At this point, one of the following is expected:
  * the keyword 'is' followed by the body as an expression;
  * a colon ':' followed by the return type.

contract: Function Ident With
##
## Ends in an error in state: 420.
##
## fun_decl -> Function Ident . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function Ident . parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident
##
contract: Recursive Function Ident With
##
## Ends in an error in state: 116.
##
## fun_decl -> Recursive Function Ident . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function Ident . parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident
##
contract: Attr Recursive Function Ident With
##
## Ends in an error in state: 445.
##
## fun_decl -> nseq(Attr) Recursive Function Ident . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Recursive Function Ident . parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function Ident
##
contract: Attr Function Ident With
##
## Ends in an error in state: 454.
##
## fun_decl -> nseq(Attr) Function Ident . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Function Ident . parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function Ident
##

Ill-formed function declaration.
At this point, parameters' declarations are expected between
parentheses.

contract: Recursive With
##
## Ends in an error in state: 114.
##
## fun_decl -> Recursive . Function Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive . Function Ident parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive
##
contract: Attr Recursive With
##
## Ends in an error in state: 443.
##
## fun_decl -> nseq(Attr) Recursive . Function Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Recursive . Function Ident parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive
##

Ill-formed recursive function declaration.
At this point, the keyword 'function' is expected, followed by the name
of the function.

contract: Type Ident Is BigMap With
##
## Ends in an error in state: 35.
##
## type_ctor_app -> BigMap . type_tuple [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap
##

Ill-formed big map type.
At this point, a pair of types is expected: the type of the keys and
the type of the values.

contract: Type Ident Is Map With
##
## Ends in an error in state: 27.
##
## type_ctor_app -> Map . type_tuple [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Map
##

Ill-formed map type.
At this point, a pair of types is expected: the type of the keys and
the type of the values.

contract: Type Ident Is UIdent DOT With
##
## Ends in an error in state: 15.
##
## module_path(par_type_expr) -> UIdent DOT . module_path(par_type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(par_type_expr) -> UIdent DOT . par_type_expr [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(type_name) -> UIdent DOT . module_path(type_name) [ LPAR ]
## module_path(type_name) -> UIdent DOT . Ident [ LPAR ]
## module_path(type_name_expr) -> UIdent DOT . module_path(type_name_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(type_name_expr) -> UIdent DOT . type_name_expr [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a type in a module.
At this point, one of the following is expected:
  * a submodule name;
  * a type name.

contract: Type Ident Is UIdent Of With
##
## Ends in an error in state: 13.
##
## of_type_expr -> Of . fun_type_level [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## Of
##

Ill-formed variant definition.
At this point, a type is expected as the parameter of the constructor.
Note: If you want a sum type, use parentheses.

contract: Type Ident Is UIdent VBAR With
##
## Ends in an error in state: 41.
##
## nsepseq(variant,VBAR) -> variant VBAR . nsepseq(variant,VBAR) [ Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## variant VBAR
##
contract: Type Ident Is VBAR With
##
## Ends in an error in state: 11.
##
## sum_type -> VBAR . nsepseq(variant,VBAR) [ Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed sum type.
At this point, a variant is expected, starting with a data constructor.

contract: Type Ident Is WILD TIMES UIdent With
##
## Ends in an error in state: 14.
##
## module_path(par_type_expr) -> UIdent . DOT module_path(par_type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(par_type_expr) -> UIdent . DOT par_type_expr [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(type_name) -> UIdent . DOT module_path(type_name) [ LPAR ]
## module_path(type_name) -> UIdent . DOT Ident [ LPAR ]
## module_path(type_name_expr) -> UIdent . DOT module_path(type_name_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(type_name_expr) -> UIdent . DOT type_name_expr [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a type in a module.
At this point, the selection symbol '.' is expected.

contract: Type Ident Is With
##
## Ends in an error in state: 9.
##
## type_decl -> Type Ident Is . type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident Is
##
contract: Type Ident LPAR Ident RPAR Is With
##
## Ends in an error in state: 111.
##
## type_decl -> Type Ident type_params Is . type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident type_params Is
##

Ill-formed type declaration.
At this point, a type expression is expected.

contract: Type Ident Is LPAR With
##
## Ends in an error in state: 16.
##
## par(type_expr) -> LPAR . type_expr RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised type expression.
At this point, a type expression is expected.

contract: Type Ident Is LPAR String With
##
## Ends in an error in state: 99.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 70, spurious reduction of production cartesian_level -> core_type
## In state 77, spurious reduction of production fun_type_level -> cartesian_level
## In state 69, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed parenthesised type expression.
At this point, if the type expression is complete, a closing
parenthesis ')' is expected.

contract: Type Ident Is List With
##
## Ends in an error in state: 29.
##
## type_ctor_app -> List . par(type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List
##

Ill-formed list type.
At this point, the type of the elements is expected between
parentheses.

contract: Type Ident Is Map LPAR String With
##
## Ends in an error in state: 49.
##
## nsepseq(type_expr,COMMA) -> type_expr . [ RPAR ]
## nsepseq(type_expr,COMMA) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 70, spurious reduction of production cartesian_level -> core_type
## In state 77, spurious reduction of production fun_type_level -> cartesian_level
## In state 69, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed type tuple.
At this point, if the type expression is complete, one of the
following is expected:
  * a comma ',' followed by another component as a type expression;
  * a closing parenthesis ')' if there are no more components..

contract: Type Ident Is Map LPAR With
##
## Ends in an error in state: 28.
##
## par(nsepseq(type_expr,COMMA)) -> LPAR . nsepseq(type_expr,COMMA) RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
contract: Type Ident Is Map LPAR WILD COMMA With
##
## Ends in an error in state: 50.
##
## nsepseq(type_expr,COMMA) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##

Ill-formed type parameters.
At this point, a parameter is expected as a type expression.

contract: Const UIdent COLON Record Ident RBRACKET
##
## Ends in an error in state: 97.
##
## verb_inj(Record,field_decl) -> Record sep_or_term_list(field_decl,SEMI) . End [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record sep_or_term_list(field_decl,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 25, spurious reduction of production field_decl -> Ident
## In state 92, spurious reduction of production nsepseq(field_decl,SEMI) -> field_decl
## In state 91, spurious reduction of production sep_or_term_list(field_decl,SEMI) -> nsepseq(field_decl,SEMI)
##

Ill-formed record type.
At this point, if the field is complete, one of the following is
expected:
  * a semicolon ';' followed by another field;
  * the keyword 'end' if the record is complete.

contract: Type Ident Is Record Ident COLON With
##
## Ends in an error in state: 26.
##
## field_decl -> Ident COLON . type_expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## Ident COLON
##

Ill-formed type annotation.
At this point, a type expression is expected.

contract: Const UIdent COLON Record LBRACKET Ident End
##
## Ends in an error in state: 84.
##
## terse_inj(Record,field_decl) -> Record LBRACKET sep_or_term_list(field_decl,SEMI) . RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_decl,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 25, spurious reduction of production field_decl -> Ident
## In state 92, spurious reduction of production nsepseq(field_decl,SEMI) -> field_decl
## In state 91, spurious reduction of production sep_or_term_list(field_decl,SEMI) -> nsepseq(field_decl,SEMI)
##
interactive_expr: Record LBRACKET Ident EQ UIdent End
##
## Ends in an error in state: 152.
##
## terse_inj(Record,field_path_assignment) -> Record LBRACKET sep_or_term_list(field_path_assignment,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_path_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 712, spurious reduction of production field_path_assignment -> field_path EQ expr
## In state 156, spurious reduction of production nsepseq(field_path_assignment,SEMI) -> field_path_assignment
## In state 155, spurious reduction of production sep_or_term_list(field_path_assignment,SEMI) -> nsepseq(field_path_assignment,SEMI)
##

Ill-formed record type.
At this point, if the field is complete, one of the following is
expected:
  * a semicolon ';' followed by another field;
  * a closing bracket ']' if the record is complete.

contract: Type Ident Is Set With
##
## Ends in an error in state: 20.
##
## type_ctor_app -> Set . par(type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Set
##

Ill-formed set type.
At this point, the type of the elements is expected between
parentheses.

contract: Type Ident Is String ARROW With
##
## Ends in an error in state: 78.
##
## fun_type_level -> cartesian_level ARROW . fun_type_level [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## cartesian_level ARROW
##

Ill-formed function type.
At this point, the return type is expected.
Note: If it is a sum type, use parentheses.

contract: Type Ident Is String TIMES String TIMES With
##
## Ends in an error in state: 75.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##
contract: Type Ident Is String TIMES With
##
## Ends in an error in state: 71.
##
## cartesian_level -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

Ill-formed product type.
At this point, a type expression is expected.
Hint: You may want to check the priority and associativity of
type operators, or use parentheses.

contract: Type Ident With
##
## Ends in an error in state: 2.
##
## type_decl -> Type Ident . Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## type_decl -> Type Ident . type_params Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident
##

Ill-formed type declaration.
At this point, one of the following is expected:
  * an open parenthesis '(' followed by a type variable;
  * the keyword 'is' followed by a type expression.

contract: Type Ident LPAR Ident RPAR With
##
## Ends in an error in state: 110.
##
## type_decl -> Type Ident type_params . Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident type_params
##

Ill-formed parametric type declaration.
At this point, the keyword 'is' is expected, followed by a type
expression.

contract: Type With
##
## Ends in an error in state: 1.
##
## type_decl -> Type . Ident Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## type_decl -> Type . Ident type_params Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point, the name of the type is expected.

contract: Type Ident Is VBAR Attr With
##
## Ends in an error in state: 42.
##
## variant -> nseq(Attr) . UIdent [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
## variant -> nseq(Attr) . UIdent of_type_expr [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 37, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed variant.
At this point, if the attribute is complete, one of the following is
expected:
  * another attribute for the variant;
  * the data constructor of the variant.

contract: Const Ident COLON UIdent With
##
## Ends in an error in state: 435.
##
## unqualified_decl(EQ) -> core_pattern COLON type_expr . EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 17, spurious reduction of production variant -> UIdent
## In state 40, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 53, spurious reduction of production type_expr -> sum_type
##

Ill-formed constant declaration.
At this point, if the type is complete, the assignment symbol '=' is
expected, followed by an expression whose value is that of the
constant.

interactive_expr: Map Verbatim ARROW Bytes SEMI With
##
## Ends in an error in state: 709.
##
## verb_inj(Map,binding) -> Map sep_or_term_list(binding,SEMI) . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Map sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 642, spurious reduction of production nseq(__anonymous_0(binding,SEMI)) -> binding SEMI
## In state 636, spurious reduction of production sep_or_term_list(binding,SEMI) -> nseq(__anonymous_0(binding,SEMI))
##

Ill-formed map expression.
At this point, if the key/value binding is complete, one of the
following is expected:
  * a semicolon ';' followed by another binding;
  * the keyword 'end' if the map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Case Verbatim Of List WILD SEMI With
##
## Ends in an error in state: 281.
##
## verb_inj(List,core_pattern) -> List sep_or_term_list(core_pattern,SEMI) . End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List sep_or_term_list(core_pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 277, spurious reduction of production nseq(__anonymous_0(core_pattern,SEMI)) -> core_pattern SEMI
## In state 274, spurious reduction of production sep_or_term_list(core_pattern,SEMI) -> nseq(__anonymous_0(core_pattern,SEMI))
##

Ill-formed list pattern.
At this point, if the element is complete, one of the following
is expected:
  * a semicolon ';' followed by another element as a pattern;
  * the keyword 'end' if the list is complete.

interactive_expr: Record Ident EQ Bytes SEMI With
##
## Ends in an error in state: 714.
##
## verb_inj(Record,field_path_assignment) -> Record sep_or_term_list(field_path_assignment,SEMI) . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record sep_or_term_list(field_path_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 157, spurious reduction of production nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI
## In state 154, spurious reduction of production sep_or_term_list(field_path_assignment,SEMI) -> nseq(__anonymous_0(field_path_assignment,SEMI))
##

Ill-formed record expression.
At this point, if the field assignment is complete, one of the
following is expected:
  * a semicolon ';' followed by another assignment;
  * a keyword 'end' if the record is complete.

contract: With
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed contract.
At this point, a top-level declaration is expected, starting with the
keyword 'type', 'const', 'function', 'recursive' or 'module'.

contract: Type Ident Is Record With
##
## Ends in an error in state: 22.
##
## terse_inj(Record,field_decl) -> Record . LBRACKET RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## terse_inj(Record,field_decl) -> Record . LBRACKET sep_or_term_list(field_decl,SEMI) RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## verb_inj(Record,field_decl) -> Record . End [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## verb_inj(Record,field_decl) -> Record . sep_or_term_list(field_decl,SEMI) End [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed record type declaration.
At this point, one of the following is expected:
  * field declarations separated by semicolons ';';
  * an opening bracket '[' followed by a field declaration;
  * brackets '[]' or the keyword 'end' if the record is empty.

contract: Type Ident Is Attr Recursive
##
## Ends in an error in state: 58.
##
## record_type -> nseq(Attr) . injection(Record,field_decl) [ Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## sum_type -> nseq(Attr) . VBAR nsepseq(variant,VBAR) [ Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
## variant -> nseq(Attr) . UIdent [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
## variant -> nseq(Attr) . UIdent of_type_expr [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 37, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed record or sum type.
At this point, if the attribute is complete, one of the following is
expected:
  * another attribute;
  * a record type, starting with the keyword 'record';
  * a variant starting with a data constructor;
  * a vertical bar '|' if the attributes apply to a sum type, not its
    first variant.

contract: Type Ident Is Attr VBAR With
##
## Ends in an error in state: 59.
##
## sum_type -> nseq(Attr) VBAR . nsepseq(variant,VBAR) [ Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) VBAR
##

Ill-formed sum type.
At this point, one of the following is expected:
  * attributes of a variant;
  * the data constructor of a variant.

contract: Type Ident Is Record Attr VBAR
##
## Ends in an error in state: 87.
##
## field_decl -> nseq(Attr) . Ident [ SEMI RBRACKET End ]
## field_decl -> nseq(Attr) . Ident COLON type_expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 37, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed record type.
At this point, if the attribute is complete, the following is
expected:
  * another attribute of the field;
  * the name of the field.

contract: Type Ident Is Attr Record LBRACKET With
##
## Ends in an error in state: 23.
##
## terse_inj(Record,field_decl) -> Record LBRACKET . RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## terse_inj(Record,field_decl) -> Record LBRACKET . sep_or_term_list(field_decl,SEMI) RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record type.
At this point, one of the following is expected:
  * field declarations separated by semicolons ';';
  * a closing bracket ']' if the record is empty.

interactive_expr: Block LBRACE With
##
## Ends in an error in state: 219.
##
## terse_block -> option(Block) LBRACE . sep_or_term_list(statement,SEMI) RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## option(Block) LBRACE
##
interactive_expr: Begin With
##
## Ends in an error in state: 182.
##
## verb_block -> Begin . sep_or_term_list(statement,SEMI) End [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Begin
##

Ill-formed block of statements.
At this point, statements are expected, separated by semicolons ';'.
Note: A statement is either an instruction or a declaration.

contract: Attr VBAR
##
## Ends in an error in state: 442.
##
## const_decl -> nseq(Attr) . Const unqualified_decl(EQ) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) . Function Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) . Function Ident parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) . Recursive Function Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) . Recursive Function Ident parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 37, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed constant or function declaration.
At this point, if the attribute is complete, one of the following is
expected:
  * another attribute;
  * the keyword 'const' if defining a constant;
  * the keyword 'function' if defining a function;
  * the keywords 'recursive function' if defining a recursive
    function.

contract: Type Ident Is UIdent With
##
## Ends in an error in state: 736.
##
## contract -> nseq(top_declaration) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## nseq(top_declaration)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 17, spurious reduction of production variant -> UIdent
## In state 40, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 53, spurious reduction of production type_expr -> sum_type
## In state 109, spurious reduction of production type_decl -> Type Ident Is type_expr
## In state 439, spurious reduction of production declaration -> type_decl
## In state 734, spurious reduction of production option(SEMI) ->
## In state 735, spurious reduction of production top_declaration -> declaration option(SEMI)
## In state 732, spurious reduction of production nseq(top_declaration) -> top_declaration
##

Ill-formed contract.
At this point, if the top-level declaration is complete, one the
following is expected:
  * another declaration starting with the keyword 'type', 'const',
    'function', 'recursive' or 'module';
  * the end of the file.

contract: Module UIdent Is Begin Type Ident Is UIdent RBRACE
##
## Ends in an error in state: 467.
##
## verb_module_decl -> Module UIdent Is Begin declarations . End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is Begin declarations
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 17, spurious reduction of production variant -> UIdent
## In state 40, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 53, spurious reduction of production type_expr -> sum_type
## In state 109, spurious reduction of production type_decl -> Type Ident Is type_expr
## In state 439, spurious reduction of production declaration -> type_decl
## In state 469, spurious reduction of production option(SEMI) ->
## In state 471, spurious reduction of production nseq(__anonymous_2) -> declaration option(SEMI)
## In state 441, spurious reduction of production declarations -> nseq(__anonymous_2)
##

Ill-formed module declaration.
At this point, if the declaration is complete, one of the
following is expected:
  * another declaration starting with the keyword 'type', 'const',
    'function', 'recursive' or 'module';
  * the keyword 'end' if there are no more declarations.

contract: Module UIdent Is Begin With
##
## Ends in an error in state: 418.
##
## verb_module_decl -> Module UIdent Is Begin . declarations End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is Begin
##
contract: Module UIdent Is LBRACE With
##
## Ends in an error in state: 475.
##
## terse_module_decl -> Module UIdent Is option(Block) LBRACE . declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is option(Block) LBRACE
##

Ill-formed module declaration.
At this point, one of the following is expected:
  * a type declaration starting with the keyword 'type';
  * a constant declaration starting with the keyword 'const';
  * a (sub)module declaration starting with the keyword 'module';
  * a function declaration starting with the keyword 'function' or
    'recursive'.
Note: Some declarations can start with attributes.

contract: Module UIdent Is LBRACE Type Ident Is UIdent End
##
## Ends in an error in state: 476.
##
## terse_module_decl -> Module UIdent Is option(Block) LBRACE declarations . RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is option(Block) LBRACE declarations
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 17, spurious reduction of production variant -> UIdent
## In state 40, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 53, spurious reduction of production type_expr -> sum_type
## In state 109, spurious reduction of production type_decl -> Type Ident Is type_expr
## In state 439, spurious reduction of production declaration -> type_decl
## In state 469, spurious reduction of production option(SEMI) ->
## In state 471, spurious reduction of production nseq(__anonymous_2) -> declaration option(SEMI)
## In state 441, spurious reduction of production declarations -> nseq(__anonymous_2)
##

Ill-formed module declaration.
At this point, if the declaration is complete, one of the
following is expected:
  * another declaration starting with the keyword 'type', 'const',
    'function', 'recursive' or 'module';
  * a closing brace '}' if there are no more declarations.

contract: Module UIdent Is With
##
## Ends in an error in state: 414.
##
## module_alias -> Module UIdent Is . nsepseq(module_name,DOT) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## terse_module_decl -> Module UIdent Is . option(Block) LBRACE declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## verb_module_decl -> Module UIdent Is . Begin declarations End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is
##

Ill-formed module declaration.
At this point, one of the following is expected:
  * the qualified name of a module being aliased, e.g. 'A.B.C';
  * a module structure (block), either starting with an opening brace
    '{' (terse dialect) or the keyword 'begin' (verbose dialect).

contract: Module UIdent With
##
## Ends in an error in state: 413.
##
## module_alias -> Module UIdent . Is nsepseq(module_name,DOT) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## terse_module_decl -> Module UIdent . Is option(Block) LBRACE declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## verb_module_decl -> Module UIdent . Is Begin declarations End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent
##

Ill-formed module declaration.
At this point, the keyword 'is' is expected.

contract: Module With
##
## Ends in an error in state: 412.
##
## module_alias -> Module . UIdent Is nsepseq(module_name,DOT) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## terse_module_decl -> Module . UIdent Is option(Block) LBRACE declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## verb_module_decl -> Module . UIdent Is Begin declarations End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module
##

Ill-formed module declaration.
At this point, the name of the module is expected.

contract: Module UIdent Is UIdent DOT With
##
## Ends in an error in state: 416.
##
## nsepseq(module_name,DOT) -> UIdent DOT . nsepseq(module_name,DOT) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed module qualification.
At this point, a module name is expected.

contract: Type Ident LPAR Ident With
##
## Ends in an error in state: 4.
##
## nsepseq(type_param,COMMA) -> Ident . [ RPAR ]
## nsepseq(type_param,COMMA) -> Ident . COMMA nsepseq(type_param,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed polymorphic type declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another type parameter;
  * a closing parenthesis ')' if there are no more parameters.

contract: Type Ident LPAR With
##
## Ends in an error in state: 3.
##
## par(nsepseq(type_param,COMMA)) -> LPAR . nsepseq(type_param,COMMA) RPAR [ Is ]
##
## The known suffix of the stack is as follows:
## LPAR
##
contract: Type Ident LPAR Ident COMMA With
##
## Ends in an error in state: 5.
##
## nsepseq(type_param,COMMA) -> Ident COMMA . nsepseq(type_param,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Ident COMMA
##

Ill-formed polymorphic type declaration.
At this point, a type parameter is expected.

contract: Const UIdent COLON Ident TIMES Attr With
##
## Ends in an error in state: 72.
##
## record_type -> nseq(Attr) . injection(Record,field_decl) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 37, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed record type.
At this point, if the attribute is complete, the keyword 'record' is
expected.

contract: Const Attr With
##
## Ends in an error in state: 127.
##
## var_pattern -> nseq(Attr) . Ident [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 37, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed pattern variable.
At this point, if the attribute is complete, a variable is
expected.

contract: Const LPAR UIdent COLON UIdent ARROW
##
## Ends in an error in state: 239.
##
## par(typed_pattern) -> LPAR typed_pattern . RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR typed_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 17, spurious reduction of production variant -> UIdent
## In state 40, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 53, spurious reduction of production type_expr -> sum_type
## In state 269, spurious reduction of production typed_pattern -> pattern COLON type_expr
##

Ill-formed typed pattern.
At this point, if the type is complete, a closing parenthesis ')' is
expected.

contract: Const LPAR UIdent COMMA UIdent With
##
## Ends in an error in state: 250.
##
## nsepseq(pattern,COMMA) -> pattern . [ RPAR ]
## nsepseq(pattern,COMMA) -> pattern . COMMA nsepseq(pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 221, spurious reduction of production ctor_app(ctor_params) -> UIdent
## In state 260, spurious reduction of production ctor_pattern -> ctor_app(ctor_params)
## In state 259, spurious reduction of production core_pattern -> ctor_pattern
## In state 261, spurious reduction of production pattern -> core_pattern
##

Ill-formed tuple pattern.
At this point, if the component is complete, one of the following is
expected:
  * a comma ',' followed by another component as a pattern;
  * a closing parenthesis ')' if there are no more components.

contract: Const UIdent LPAR UIdent COMMA UIdent With
##
## Ends in an error in state: 301.
##
## nsepseq(ctor_param_pattern,COMMA) -> ctor_param_pattern . [ RPAR ]
## nsepseq(ctor_param_pattern,COMMA) -> ctor_param_pattern . COMMA nsepseq(ctor_param_pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_param_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 221, spurious reduction of production ctor_app(ctor_params) -> UIdent
## In state 260, spurious reduction of production ctor_pattern -> ctor_app(ctor_params)
## In state 259, spurious reduction of production core_pattern -> ctor_pattern
## In state 261, spurious reduction of production pattern -> core_pattern
## In state 297, spurious reduction of production ctor_param_pattern -> pattern
##

Ill-formed constructor pattern.
At this point, if the parameter is complete, one of the following is
expected:
  * a comma ',' followed by another parameter as a pattern;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: Case Verbatim Of UIdent LPAR With
##
## Ends in an error in state: 222.
##
## par(tuple(ctor_param_pattern)) -> LPAR . tuple(ctor_param_pattern) RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
contract: Const UIdent LPAR UIdent COMMA With
##
## Ends in an error in state: 299.
##
## tuple(ctor_param_pattern) -> ctor_param_pattern COMMA . nsepseq(ctor_param_pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_param_pattern COMMA
##
contract: Const UIdent LPAR UIdent COMMA UIdent COMMA With
##
## Ends in an error in state: 302.
##
## nsepseq(ctor_param_pattern,COMMA) -> ctor_param_pattern COMMA . nsepseq(ctor_param_pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_param_pattern COMMA
##

Ill-formed constructor pattern.
At this point, a parameter is expected as a pattern.

contract: Const UIdent LPAR UIdent With
##
## Ends in an error in state: 298.
##
## tuple(ctor_param_pattern) -> ctor_param_pattern . COMMA nsepseq(ctor_param_pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_param_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 221, spurious reduction of production ctor_app(ctor_params) -> UIdent
## In state 260, spurious reduction of production ctor_pattern -> ctor_app(ctor_params)
## In state 259, spurious reduction of production core_pattern -> ctor_pattern
## In state 261, spurious reduction of production pattern -> core_pattern
## In state 297, spurious reduction of production ctor_param_pattern -> pattern
##

Ill-formed constructor pattern.
At this point, if the parameter is complete, a comma ',' is expected,
followed by another parameter as a pattern.

contract: Const LPAR UIdent COMMA UIdent COMMA With
##
## Ends in an error in state: 251.
##
## nsepseq(pattern,COMMA) -> pattern COMMA . nsepseq(pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern COMMA
##

Ill-formed tuple pattern.
At this point, a component is expected as a pattern.

interactive_expr: UIdent With Record LBRACKET Ident EQ UIdent While
##
## Ends in an error in state: 156.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACKET End ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACKET End ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI [ RBRACKET End ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI nseq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACKET End ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 712, spurious reduction of production field_path_assignment -> field_path EQ expr
##

Ill-formed record update.
At this point, if the field assignment is complete, one of the
following is expected:
  * a semicolon ';' followed by another field assignment (update);
  * a closing bracket ']' if the update is complete.

interactive_expr: UIdent DOT UIdent DOT With
##
## Ends in an error in state: 396.
##
## module_path(And) -> UIdent DOT . module_path(And) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(And) -> UIdent DOT . And [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(Or) -> UIdent DOT . module_path(Or) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(Or) -> UIdent DOT . Or [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(field_path) -> UIdent DOT . module_path(field_path) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(field_path) -> UIdent DOT . field_path [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a value in a module.
At this point, one of the following is expected:
  * a submodule name;
  * a value name.

interactive_expr: Begin Remove UIdent While
##
## Ends in an error in state: 405.
##
## remove_instr(expr) -> Remove expr . From expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##
interactive_expr: Begin If UIdent Then Remove UIdent While
##
## Ends in an error in state: 487.
##
## remove_instr(closed_expr) -> Remove expr . From closed_expr [ Else ]
## remove_instr(expr) -> Remove expr . From expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed removal from a big map/map/set.
At this point, if the item to remove is complete, the keyword `from`
is expected.

contract: Module UIdent Is Block With
##
## Ends in an error in state: 474.
##
## terse_module_decl -> Module UIdent Is option(Block) . LBRACE declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is option(Block)
##

Ill-formed module declaration.
At this point, an opening brace '{' is expected, followed by
declarations.

interactive_expr: Begin LPAR With
##
## Ends in an error in state: 479.
##
## par(expr) -> LPAR . expr RPAR [ LBRACKET DOT ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised expression.
At this point, an expression is expected, followed by a closing
parenthesis ')'.

interactive_expr: Begin LPAR UIdent While
##
## Ends in an error in state: 480.
##
## par(expr) -> LPAR expr . RPAR [ LBRACKET DOT ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed parenthesised expression.
At this point, if the expression is complete, a closing parenthesis
')' is expected.

interactive_expr: Begin If UIdent While
##
## Ends in an error in state: 483.
##
## if_then_else_instr(instruction) -> If expr . Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If expr . Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##
interactive_expr: Begin If UIdent Then If UIdent While
##
## Ends in an error in state: 522.
##
## if_then_else_instr(closed_instr) -> If expr . Then test_clause(closed_instr) Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr . Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If expr . Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed conditional instruction.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an instruction or a block of statements
(instructions and declarations).

interactive_expr: If UIdent Then If UIdent While
##
## Ends in an error in state: 490.
##
## if_then_else_expr(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
## if_then_else_expr(expr) -> If expr . Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If expr . Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##
interactive_expr: If UIdent While
##
## Ends in an error in state: 671.
##
## if_then_else_expr(expr) -> If expr . Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If expr . Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed conditional expression.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an expression.

interactive_expr: If UIdent Then Function With
##
## Ends in an error in state: 492.
##
## fun_expr(closed_expr) -> Function . parameters Is closed_expr [ Else ]
## fun_expr(closed_expr) -> Function . parameters COLON type_expr Is closed_expr [ Else ]
## fun_expr(expr) -> Function . parameters Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function . parameters COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function
##
interactive_expr: Function With
##
## Ends in an error in state: 173.
##
## fun_expr(expr) -> Function . parameters Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function . parameters COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function
##

Ill-formed function expression.
At this point, parameters' declarations are expected between
parentheses.

interactive_expr: If UIdent Then LBRACE Skip RBRACE While
##
## Ends in an error in state: 502.
##
## block_with(closed_expr) -> block . With closed_expr [ Else ]
## block_with(expr) -> block . With expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block
##

Ill-formed block expression.
At this point, the keyword 'with' is expected, followed by an
expression whose value is that of the block.

interactive_expr: Begin For Ident ASS UIdent While
##
## Ends in an error in state: 534.
##
## for_int -> For Ident ASS expr . To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS expr . To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed iteration over a numerical interval.
At this point, if the initial value of the index is complete, the
keyword 'to' is expected, followed by an expression whose value is the
final value of the index.

interactive_expr: Begin For Ident ASS UIdent To UIdent While
##
## Ends in an error in state: 536.
##
## for_int -> For Ident ASS expr To expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS expr To expr . step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed iteration over a numerical interval.
At this point, if the final value of the index is complete, one of the
following is expected:
  * a step clause introduced by the keyword 'step' and followed by
    the index increment as an expression;
  * a loop body as a block of statements (instructions and
    declarations).

interactive_expr: Begin Case UIdent While
##
## Ends in an error in state: 549.
##
## terse_case(test_clause(instruction)) -> Case expr . Of LBRACKET cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## terse_case(test_clause(instruction)) -> Case expr . Of LBRACKET VBAR cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## verb_case(test_clause(instruction)) -> Case expr . Of cases(test_clause(instruction)) End [ VBAR SEMI RBRACKET RBRACE End Else ]
## verb_case(test_clause(instruction)) -> Case expr . Of VBAR cases(test_clause(instruction)) End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed case instruction.
At this point, if the analysed expression is complete, the keyword
'of' is expected, followed by clauses separated or starting by
vertical bars '|'.
Note: A clause, here, is made of a pattern and an instruction or
a block of statements, separated by an arrow '->'.

interactive_expr: Begin LPAR UIdent RPAR With
##
## Ends in an error in state: 564.
##
## local_path -> par(expr) . DOT nsepseq(selection,DOT) [ LPAR LBRACKET ASS ]
## map_lookup -> par(expr) . brackets(expr) [ ASS ]
##
## The known suffix of the stack is as follows:
## par(expr)
##

Ill-formed selection from a record, tuple or map.
At this point, one of the following is expected:
  * the selection symbol '.', followed either by a record field name
    or a tuple component number (0 denoting the first);
  * an opening bracket '[' if looking up a value in a map.

interactive_expr: Ident LBRACKET UIdent While
##
## Ends in an error in state: 628.
##
## brackets(expr) -> LBRACKET expr . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed map lookup.
At this point, if the key is complete, a closing bracket ']' is
expected.

interactive_expr: Begin While UIdent While
##
## Ends in an error in state: 630.
##
## while_loop -> While expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## While expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed general loop.
At this point, if the condition is complete, the body of the loop is
expected as a block of statements (instructions and declarations).

interactive_expr: BigMap LBRACKET UIdent ARROW UIdent While
##
## Ends in an error in state: 634.
##
## terse_inj(BigMap,binding) -> BigMap LBRACKET sep_or_term_list(binding,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap LBRACKET sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 640, spurious reduction of production binding -> expr ARROW expr
## In state 641, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 637, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##

Ill-formed big map expression.
At this point, if the key/value binding is complete, one of the
following is expected:
  * a semicolon ';' followed by another binding;
  * a closing bracket ']' if the big map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: BigMap UIdent While
##
## Ends in an error in state: 638.
##
## binding -> expr . ARROW expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed key/value binding in a map.
At this point, if the key is complete, an arrow '->' is expected,
followed by an expression whose value is associated to the key.

interactive_expr: BigMap UIdent ARROW UIdent While
##
## Ends in an error in state: 646.
##
## verb_inj(BigMap,binding) -> BigMap sep_or_term_list(binding,SEMI) . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 640, spurious reduction of production binding -> expr ARROW expr
## In state 641, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 637, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##

Ill-formed big map expression.
At this point, if the key/value binding is complete, one of the
following is expected:
  * a semicolon ';' followed by another binding;
  * the keyword 'end' if the big map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Case UIdent While
##
## Ends in an error in state: 648.
##
## terse_case(expr) -> Case expr . Of LBRACKET cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## terse_case(expr) -> Case expr . Of LBRACKET VBAR cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## verb_case(expr) -> Case expr . Of cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## verb_case(expr) -> Case expr . Of VBAR cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed case expression.
At this point, if the analysed expression is complete, the keyword
'of' is expected, followed by clauses separated or starting by
vertical bars '|'.
Note: A clause, here, is made of a pattern and an expression,
separated by an arrow '->'.

interactive_expr: Case UIdent Of UIdent ARROW UIdent While
##
## Ends in an error in state: 666.
##
## verb_case(expr) -> Case expr Of cases(expr) . End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of cases(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 653, spurious reduction of production case_clause(expr) -> pattern ARROW expr
## In state 657, spurious reduction of production nsepseq(case_clause(expr),VBAR) -> case_clause(expr)
## In state 654, spurious reduction of production cases(expr) -> nsepseq(case_clause(expr),VBAR)
##
interactive_expr: Case UIdent Of VBAR UIdent ARROW UIdent While
##
## Ends in an error in state: 655.
##
## verb_case(expr) -> Case expr Of VBAR cases(expr) . End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of VBAR cases(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 653, spurious reduction of production case_clause(expr) -> pattern ARROW expr
## In state 657, spurious reduction of production nsepseq(case_clause(expr),VBAR) -> case_clause(expr)
## In state 654, spurious reduction of production cases(expr) -> nsepseq(case_clause(expr),VBAR)
##

Ill-formed case expression.
At this point, if the clause is complete, one of the following is
expected:
  * a vertical bar '|' followed by another clause;
  * the keyword 'end' if the case is complete.
Note: A clause, here, is made of a pattern and an expression separated
by an arrow '->'.

interactive_expr: LPAR UIdent COMMA UIdent While
##
## Ends in an error in state: 682.
##
## nsepseq(expr,COMMA) -> expr . [ RPAR ]
## nsepseq(expr,COMMA) -> expr . COMMA nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed function call.
At this point, if the argument is complete, one of the following is
expected:
  * a comma ',' followed by another argument as an expression;
  * a closing parenthesis ')' if there are no more arguments.

interactive_expr: LPAR UIdent While
##
## Ends in an error in state: 679.
##
## par(expr) -> LPAR expr . RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive DOT Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## tuple(expr) -> expr . COMMA nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 685, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed parenthesised/tuple expression.
At this point, if the expression is complete, one of the following is
expected:
  * a comma ',' followed by a component as an expression, if defining
    a tuple;
  * a closing parenthesis ')' if defining a parenthesised expression.

interactive_expr: Lang UIdent While
##
## Ends in an error in state: 688.
##
## code_inj -> Lang expr . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Lang expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed code injection.
At this point, if the expression denoting the code to inject is
complete, then a closing bracket ']' is expected.

interactive_expr: List LBRACKET UIdent While
##
## Ends in an error in state: 692.
##
## terse_inj(List,expr) -> List LBRACKET sep_or_term_list(expr,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 696, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 695, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##

Ill-formed list expression.
At this point, if the element is complete, one of the following
is expected:
  * a semicolon ';' followed by another element as an expression;
  * a closing bracket ']' if the list is complete.

interactive_expr: List UIdent While
##
## Ends in an error in state: 701.
##
## verb_inj(List,expr) -> List sep_or_term_list(expr,SEMI) . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## List sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 696, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 695, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##

Ill-formed list expression.
At this point, if the element is complete, one of the following
is expected:
  * a semicolon ';' followed by another element as an expression;
  * the keyword 'end' if the list is complete.

interactive_expr: Map LBRACKET UIdent ARROW UIdent While
##
## Ends in an error in state: 706.
##
## terse_inj(Map,binding) -> Map LBRACKET sep_or_term_list(binding,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Map LBRACKET sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 640, spurious reduction of production binding -> expr ARROW expr
## In state 641, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 637, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##

Ill-formed map expression.
At this point, if the key/value binding is complete, one of the
following is expected:
  * a semicolon ';' followed by another binding;
  * a closing bracket ']' if the map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Record LBRACKET Ident While
##
## Ends in an error in state: 160.
##
## field_path_assignment -> field_path . EQ expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## field_path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production field_path -> Ident
##

Ill-formed record expression.
At this point, if the field assignment is complete, one of the
following is expected:
  * a semicolon ';' followed by another assignment;
  * a closing bracket ']' if the record is complete.

interactive_expr: Set LBRACKET UIdent While
##
## Ends in an error in state: 718.
##
## terse_inj(Set,expr) -> Set LBRACKET sep_or_term_list(expr,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Set LBRACKET sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 696, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 695, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##

Ill-formed set expression.
At this point, if the element is complete, one of the following is
expected:
  * a semicolon ';' followed by another element as an expression;
  * a closing bracket ']' if the set is complete.

interactive_expr: Set UIdent While
##
## Ends in an error in state: 721.
##
## verb_inj(Set,expr) -> Set sep_or_term_list(expr,SEMI) . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Set sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 137, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 329, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 328, spurious reduction of production core_expr -> ctor_expr
## In state 330, spurious reduction of production update_expr_level -> core_expr
## In state 192, spurious reduction of production unary_expr_level -> update_expr_level
## In state 197, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 356, spurious reduction of production cons_expr_level -> add_expr_level
## In state 346, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 379, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 366, spurious reduction of production set_mem_level -> comp_expr_level
## In state 211, spurious reduction of production conj_expr_level -> set_mem_level
## In state 386, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 344, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 392, spurious reduction of production expr -> base_expr(expr)
## In state 696, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 695, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##

Ill-formed set expression.
At this point, if the element is complete, one of the following is
expected:
  * a semicolon ';' followed by another element as an expression;
  * the keyword 'end' if the set is complete.

contract: Const UIdent COLON Record Attr Ident COLON With
##
## Ends in an error in state: 89.
##
## field_decl -> nseq(Attr) Ident COLON . type_expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Ident COLON
##

Ill-formed record type.
At this point, the type of the field is expected.

contract: Const LPAR UIdent COLON With
##
## Ends in an error in state: 268.
##
## typed_pattern -> pattern COLON . type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern COLON
##

Ill-formed typed pattern.
At this point, the type of the pattern is expected.

interactive_expr: Begin Var UIdent COLON With
##
## Ends in an error in state: 308.
##
## unqualified_decl(ASS) -> core_pattern COLON . type_expr ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON
##

Ill-formed variable declaration.
At this point, the type of the variable is expected.

contract: Const UIdent COLON With
##
## Ends in an error in state: 434.
##
## unqualified_decl(EQ) -> core_pattern COLON . type_expr EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON
##

Ill-formed constant declaration.
At this point, the type of the constant is expected.

contract: Attr Recursive Function Ident LPAR Const Ident RPAR COLON With
##
## Ends in an error in state: 449.
##
## fun_decl -> nseq(Attr) Recursive Function Ident parameters COLON . type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function Ident parameters COLON
##
contract: Function Ident LPAR Const Ident RPAR COLON With
##
## Ends in an error in state: 424.
##
## fun_decl -> Function Ident parameters COLON . type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters COLON
##
contract: Attr Function Ident LPAR Const Ident RPAR COLON With
##
## Ends in an error in state: 458.
##
## fun_decl -> nseq(Attr) Function Ident parameters COLON . type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function Ident parameters COLON
##
contract: Recursive Function Ident LPAR Const Ident RPAR COLON With
##
## Ends in an error in state: 727.
##
## fun_decl -> Recursive Function Ident parameters COLON . type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters COLON
##

Ill-formed function declaration.
At this point, the return type is expected.

interactive_expr: If UIdent Then Function LPAR Const Ident RPAR COLON With
##
## Ends in an error in state: 506.
##
## fun_expr(closed_expr) -> Function parameters COLON . type_expr Is closed_expr [ Else ]
## fun_expr(expr) -> Function parameters COLON . type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON
##
interactive_expr: Function LPAR Const Ident RPAR COLON With
##
## Ends in an error in state: 668.
##
## fun_expr(expr) -> Function parameters COLON . type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON
##

Ill-formed function expression.
At this point, the return type is expected.

interactive_expr: LPAR UIdent COLON With
##
## Ends in an error in state: 686.
##
## typed_expr -> disj_expr_level COLON . type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COLON
##

Ill-formed typed expression.
At this point, a type expression is expected.
