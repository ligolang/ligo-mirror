interactive_expr: Begin Case Verbatim Of LBRACKET WILD ARROW Skip With
##
## Ends in an error in state: 582.
##
## terse_case(test_clause(instruction)) -> Case expr Of LBRACKET option(VBAR) cases(test_clause(instruction)) . RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET option(VBAR) cases(test_clause(instruction))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 584, spurious reduction of production nsepseq(case_clause(test_clause(instruction)),VBAR) -> case_clause(test_clause(instruction))
## In state 581, spurious reduction of production cases(test_clause(instruction)) -> nsepseq(case_clause(test_clause(instruction)),VBAR)
##

Ill-formed terse case instruction.
At this point, if the case clause is complete, one of the following is
expected:
  * a vertical bar '|' followed by another clause;
  * a closing bracket ']' if the case is complete.
Note: A clause, here, is made of a pattern and an instruction or
a block, separated by an arrow '->'.

interactive_expr: Begin Case Verbatim Of LBRACKET With
##
## Ends in an error in state: 541.
##
## terse_case(test_clause(instruction)) -> Case expr Of LBRACKET option(VBAR) . cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET option(VBAR)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 540, spurious reduction of production option(VBAR) ->
##
interactive_expr: Begin Case Verbatim Of With
##
## Ends in an error in state: 587.
##
## verb_case(test_clause(instruction)) -> Case expr Of option(VBAR) . cases(test_clause(instruction)) End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of option(VBAR)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 538, spurious reduction of production option(VBAR) ->
##
interactive_expr: Begin Case Verbatim Of WILD ARROW Skip VBAR With
##
## Ends in an error in state: 585.
##
## nsepseq(case_clause(test_clause(instruction)),VBAR) -> case_clause(test_clause(instruction)) VBAR . nsepseq(case_clause(test_clause(instruction)),VBAR) [ RBRACKET End ]
##
## The known suffix of the stack is as follows:
## case_clause(test_clause(instruction)) VBAR
##

Ill-formed case instruction.
At this point, a case clause is expected, made of a pattern and an
instruction or block, separated by an arrow '->'.

interactive_expr: Begin Case Verbatim Of WILD ARROW Skip With
##
## Ends in an error in state: 588.
##
## verb_case(test_clause(instruction)) -> Case expr Of option(VBAR) cases(test_clause(instruction)) . End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of option(VBAR) cases(test_clause(instruction))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 584, spurious reduction of production nsepseq(case_clause(test_clause(instruction)),VBAR) -> case_clause(test_clause(instruction))
## In state 581, spurious reduction of production cases(test_clause(instruction)) -> nsepseq(case_clause(test_clause(instruction)),VBAR)
##

Ill-formed case instruction.
At this point, if the clause is complete, one of the following is
expected:
  * a vertical bar '|' followed by another clause;
  * the keyword 'end' if the case is complete.
Note: A clause, here, is made of a pattern and an instruction or
a block, separated by an arrow '->'.

interactive_expr: Begin Case Verbatim Of WILD ARROW With
##
## Ends in an error in state: 543.
##
## case_clause(test_clause(instruction)) -> pattern ARROW . test_clause(instruction) [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

Ill-formed clause of a case instruction.
At this point, one of the following is expected:
  * a single instruction;
  * a block of statements (instructions and declarations).
Note: A clause, here, is made of a pattern and an instruction or a
block, separated by an arrow '->'. A block is either delimited by '{'
and '}' (terse dialect) or 'begin' and 'end' (verbose dialect).

interactive_expr: Begin Case Verbatim Of WILD With
##
## Ends in an error in state: 542.
##
## case_clause(test_clause(instruction)) -> pattern . ARROW test_clause(instruction) [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 241, spurious reduction of production pattern -> core_pattern
##

Ill-formed clause of a case instruction.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by one of the following:
  * a single instruction;
  * a block of statements (instructions and declarations).
Note: A block is either delimited by '{' and '}' (terse dialect) or
'begin' and 'end' (verbose dialect).

interactive_expr: Begin Case With
##
## Ends in an error in state: 536.
##
## terse_case(test_clause(instruction)) -> Case . expr Of LBRACKET option(VBAR) cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## verb_case(test_clause(instruction)) -> Case . expr Of option(VBAR) cases(test_clause(instruction)) End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case
##

Ill-formed case instruction.
At this point, the condition is expected as an expression, followed by
the keyword 'of'.

interactive_expr: Begin UIdent With
##
## Ends in an error in state: 381.
##
## module_path(field_path) -> UIdent . DOT module_path(field_path) [ LPAR LBRACKET ASS ]
## module_path(field_path) -> UIdent . DOT field_path [ LPAR LBRACKET ASS ]
## value_in_module -> UIdent . DOT Or [ LPAR LBRACKET ASS ]
## value_in_module -> UIdent . DOT And [ LPAR LBRACKET ASS ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a value from a module.
At this point, the selection symbol '.' is expected, followed by one
of the following:
  * the qualified name of a value, like 'A.B.c.d';
  * the keyword 'or' or 'and'.

interactive_expr: Begin For Ident ARROW Ident In With
##
## Ends in an error in state: 532.
##
## for_in -> For Ident ARROW Ident In . Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident In
##

Ill-formed bounded loop over a map.
At this point, the keyword 'map' is expected.

interactive_expr: Begin For Ident ARROW Ident In Map With
##
## Ends in an error in state: 533.
##
## for_in -> For Ident ARROW Ident In Map . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident In Map
##

Ill-formed bounded loop over a map.
At this point, the map to be iterated is expected as an expression.

interactive_expr: Begin For Ident ARROW Ident With
##
## Ends in an error in state: 531.
##
## for_in -> For Ident ARROW Ident . In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident
##

Ill-formed bounded loop over a map.
At this point, the keywords 'in map' are expected, followed by the map
to be iterated, as an expression.

interactive_expr: Begin For Ident ARROW With
##
## Ends in an error in state: 530.
##
## for_in -> For Ident ARROW . Ident In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW
##

Ill-formed bounded loop over a map.
At this point, a variable denoting values (as opposed to keys) in a
map is expected.

interactive_expr: Begin For Ident ASS Verbatim To Verbatim Step Verbatim Attr
##
## Ends in an error in state: 527.
##
## for_int -> For Ident ASS expr To expr step_clause . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To expr step_clause
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 526, spurious reduction of production step_clause -> Step expr
##

Ill-formed bounded loop over a numerical interval.
At this point, if the step clause is complete, the loop body is
expected as a block of instructions.
Note: A block is either delimited by '{' and '}' (terse dialect) or
'begin' and 'end' (verbose dialect).

interactive_expr: Begin For Ident ASS Verbatim To Verbatim Step With
##
## Ends in an error in state: 525.
##
## step_clause -> Step . expr [ LBRACE Block Begin ]
##
## The known suffix of the stack is as follows:
## Step
##

Ill-formed bounded loop over a numerical interval.
At this point, the index increment is expected as an expression.

interactive_expr: Begin For Ident ASS Verbatim To With
##
## Ends in an error in state: 523.
##
## for_int -> For Ident ASS expr To . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS expr To . expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To
##

Ill-formed bounded loop over a numerical interval.
At this point, the final value of the index is expected as an
expression.

interactive_expr: Begin For Ident ASS With
##
## Ends in an error in state: 521.
##
## for_int -> For Ident ASS . expr To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS . expr To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS
##

Ill-formed bounded loop over a numerical interval.
At this point, the expression for the initial value of the index is
expected.

interactive_expr: Begin For Ident In Set With
##
## Ends in an error in state: 518.
##
## for_in -> For Ident In collection . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In collection
##

Ill-formed bounded loop over a collection.
At this point, the collection is expected as an expression.

interactive_expr: Begin For Ident In With
##
## Ends in an error in state: 515.
##
## for_in -> For Ident In . collection expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In
##

Ill-formed bounded loop over a set or a list.
At this point, the keywords 'set' or 'list' are expected, followed by
the actual collection as an expression.

interactive_expr: Begin For Ident With
##
## Ends in an error in state: 514.
##
## for_in -> For Ident . ARROW Ident In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For Ident . In collection expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident . ASS expr To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident . ASS expr To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident
##

Ill-formed bounded loop.
At this point, one of the following is expected:
  * if iterating over a numerical interval, then the assignment
    symbol ':=' is expected, followed by the initial value of the
    index as an expression;
  * if iterating over a list or a set, then the keyword 'in' is
    expected, followed by either the keyword 'list' or 'set';
  * if iterating over a map, then a binding arrow '->' followed by a
    variable denoting the values of the map (as opposed to 'keys').

interactive_expr: Begin For With
##
## Ends in an error in state: 513.
##
## for_in -> For . Ident ARROW Ident In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For . Ident In collection expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For . Ident ASS expr To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For . Ident ASS expr To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For
##

Ill-formed bounded loop.
At this point, one of the following is expected:
  * a variable denoting the index, if iterating over a numerical
    interval;
  * a variable denoting an element, if iterating over a list or a set;
  * a variable denoting the key of a map (as opposed to 'values'), if
    iterating over a map.

interactive_expr: Begin Ident ASS With
##
## Ends in an error in state: 566.
##
## assignment(expr) -> lhs ASS . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## lhs ASS
##

Ill-formed assignment.
At this point, the right-hand side of the assignment is expected as an
expression.

interactive_expr: Begin Ident With
##
## Ends in an error in state: 565.
##
## assignment(expr) -> lhs . ASS expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 145, spurious reduction of production field_path -> Ident
## In state 293, spurious reduction of production local_path -> field_path
## In state 286, spurious reduction of production path_expr -> local_path
## In state 554, spurious reduction of production lhs -> path_expr
##

Ill-formed assignment.
At this point, if the left-hand side of the assignment is complete,
the assignment symbol ':=' is expected, followed by an expression.

interactive_expr: Begin If Verbatim Then Skip Else With
##
## Ends in an error in state: 618.
##
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) Else . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr) Else
##
interactive_expr: Begin If UIdent Then If UIdent Then Skip Else With
##
## Ends in an error in state: 593.
##
## if_then_else_instr(closed_instr) -> If expr Then test_clause(closed_instr) Else . test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) Else . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr) Else
##

Ill-formed conditional instruction.
At this point, the 'else' branch is expected as one of the following:
  * a single instruction;
  * a block of statements (instructions and declarations).
Note: A block, in this context, is either delimited by '{' and '}'
(terse dialect) or 'begin' and 'end' (verbose dialect).

interactive_expr: Begin If Verbatim Then Skip With
##
## Ends in an error in state: 617.
##
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) . Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 474, spurious reduction of production base_instr(closed_instr,closed_expr) -> Skip
## In state 615, spurious reduction of production closed_instr -> base_instr(closed_instr,closed_expr)
## In state 610, spurious reduction of production test_clause(closed_instr) -> closed_instr
##

Ill-formed conditional instruction.
At this point, if the 'then' branch is complete, the keyword 'else' is
expected, followed by one of the following:
  * a single instruction;
  * a block of statements (instructions and declarations).
Note: A block, in this context, is either delimited by '{' and '}'
(terse dialect) or 'begin' and 'end' (verbose dialect).

interactive_expr: Begin If Verbatim Then With
##
## Ends in an error in state: 473.
##
## if_then_else_instr(instruction) -> If expr Then . test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If expr Then . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin If UIdent Then If UIdent Then With
##
## Ends in an error in state: 512.
##
## if_then_else_instr(closed_instr) -> If expr Then . test_clause(closed_instr) Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr Then . test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If expr Then . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

Ill-formed conditional instruction.
At this point, the 'then' branch is expected as one of the following:
  * a single instruction;
  * a block of statements (instructions and declarations).
Note: A block, in this context, is either delimited by '{' and '}'
(terse dialect) or 'begin' and 'end' (verbose dialect).

interactive_expr: Begin If With
##
## Ends in an error in state: 471.
##
## if_then_else_instr(instruction) -> If . expr Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If . expr Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If UIdent Then If With
##
## Ends in an error in state: 510.
##
## if_then_else_instr(closed_instr) -> If . expr Then test_clause(closed_instr) Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If . expr Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If . expr Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional instruction.
At this point, the condition is expected as an expression.

interactive_expr: If With
##
## Ends in an error in state: 144.
##
## if_then_else_expr(expr) -> If . expr Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If . expr Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If UIdent Then If With
##
## Ends in an error in state: 479.
##
## if_then_else_expr(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
## if_then_else_expr(expr) -> If . expr Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If . expr Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional expression.
At this point, the condition is expected as an expression.

interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 150.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## selection DOT
##
interactive_expr: Ident DOT With
##
## Ends in an error in state: 146.
##
## field_path -> Ident DOT . nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##
interactive_expr: LPAR UIdent RPAR DOT With
##
## Ends in an error in state: 195.
##
## local_path -> par(expr) DOT . nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## par(expr) DOT
##

Ill-formed selection in a record or a tuple.
At this point, one of the following is expected:
  * a record field name, if selecting from a record;
  * the index of a tuple component, '0' denoting the first component.

interactive_expr: Begin Patch Ident While
##
## Ends in an error in state: 400.
##
## patch(map_expr) -> Patch core_expr . With map_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch(record_expr) -> Patch core_expr . With record_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch(set_expr) -> Patch core_expr . With set_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Patch core_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 145, spurious reduction of production field_path -> Ident
## In state 293, spurious reduction of production local_path -> field_path
## In state 286, spurious reduction of production path_expr -> local_path
## In state 187, spurious reduction of production core_expr -> path_expr
##

Ill-formed patch.
At this point, if the data structure (map, set or record) being
patched is fully qualified, the keyword 'with' is expected, followed
by a map, a set or a record expression.

interactive_expr: Record With
##
## Ends in an error in state: 129.
##
## terse_inj(Record,field_assignment) -> Record . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Record,field_assignment) -> Record . LBRACKET sep_or_term_list(field_assignment,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Record,field_assignment) -> Record . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Record,field_assignment) -> Record . sep_or_term_list(field_assignment,SEMI) End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed record expression.
At this point, one of the following is expected:
  * assignments to record fields, separated by semicolons
    ';' and followed by the keyword 'end';
  * an opening bracket '[' followed by assignments and a closing
    bracket ']'.

interactive_expr: Begin Patch Ident With With
##
## Ends in an error in state: 401.
##
## patch(map_expr) -> Patch core_expr With . map_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch(record_expr) -> Patch core_expr With . record_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch(set_expr) -> Patch core_expr With . set_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Patch core_expr With
##

Ill-formed patch.
At this point, a map, a record or a set is expected, starting with the
keywors 'map', 'record' or 'set', respectively.

interactive_expr: Begin Patch With
##
## Ends in an error in state: 399.
##
## patch(map_expr) -> Patch . core_expr With map_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch(record_expr) -> Patch . core_expr With record_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch(set_expr) -> Patch . core_expr With set_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Patch
##

Ill-formed patch.
At this point, the fully qualified name of a record, a set or a map is
expected.

interactive_expr: Begin Remove Verbatim From Map With
##
## Ends in an error in state: 395.
##
## remove(Map,expr) -> Remove expr From Map . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From Map
##
interactive_expr: Begin If UIdent Then Remove UIdent From Map With
##
## Ends in an error in state: 506.
##
## remove(Map,closed_expr) -> Remove expr From Map . closed_expr [ Else ]
## remove(Map,expr) -> Remove expr From Map . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From Map
##

Ill-formed removal from a map.
At this point, a map is expected as an expression.

interactive_expr: Begin Remove Verbatim From Set With
##
## Ends in an error in state: 393.
##
## remove(Set,expr) -> Remove expr From Set . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From Set
##
interactive_expr: Begin If UIdent Then Remove UIdent From Set With
##
## Ends in an error in state: 478.
##
## remove(Set,closed_expr) -> Remove expr From Set . closed_expr [ Else ]
## remove(Set,expr) -> Remove expr From Set . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From Set
##

Ill-formed removal from a set.
At this point, a set is expected as an expression.

interactive_expr: Begin Remove Verbatim From With
##
## Ends in an error in state: 392.
##
## remove(BigMap,expr) -> Remove expr From . BigMap expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Map,expr) -> Remove expr From . Map expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Set,expr) -> Remove expr From . Set expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From
##
interactive_expr: Begin If UIdent Then Remove UIdent From With
##
## Ends in an error in state: 477.
##
## remove(BigMap,closed_expr) -> Remove expr From . BigMap closed_expr [ Else ]
## remove(BigMap,expr) -> Remove expr From . BigMap expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Map,closed_expr) -> Remove expr From . Map closed_expr [ Else ]
## remove(Map,expr) -> Remove expr From . Map expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Set,closed_expr) -> Remove expr From . Set closed_expr [ Else ]
## remove(Set,expr) -> Remove expr From . Set expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From
##

Ill-formed removal from a collection.
At this point, either the keyword 'map', 'big_map', or 'set' is
expected.

interactive_expr: Begin Remove With
##
## Ends in an error in state: 390.
##
## remove(BigMap,expr) -> Remove . expr From BigMap expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Map,expr) -> Remove . expr From Map expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Set,expr) -> Remove . expr From Set expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove
##
interactive_expr: Begin If UIdent Then Remove With
##
## Ends in an error in state: 475.
##
## remove(BigMap,closed_expr) -> Remove . expr From BigMap closed_expr [ Else ]
## remove(BigMap,expr) -> Remove . expr From BigMap expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Map,closed_expr) -> Remove . expr From Map closed_expr [ Else ]
## remove(Map,expr) -> Remove . expr From Map expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Set,closed_expr) -> Remove . expr From Set closed_expr [ Else ]
## remove(Set,expr) -> Remove . expr From Set expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove
##

Ill-formed removal from a collection.
At this point, one of the following is expected:
  * a set element as an expression;
  * a key as an expression.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Begin Skip End While
##
## Ends in an error in state: 367.
##
## block_with(expr) -> block . With expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block
##

Ill-formed block of instructions.
At this point, the keyword 'with' is expected, followed by an
expression whose value is that of the whole block.

interactive_expr: Begin Skip End With With
##
## Ends in an error in state: 368.
##
## block_with(expr) -> block With . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block With
##

Ill-formed block of instructions.
At this point, an expression is expected, whose value is that of the
block.

interactive_expr: Begin Skip With
##
## Ends in an error in state: 634.
##
## verb_block -> Begin sep_or_term_list(statement,SEMI) . End [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Begin sep_or_term_list(statement,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 620, spurious reduction of production nsepseq(statement,SEMI) -> statement
## In state 629, spurious reduction of production sep_or_term_list(statement,SEMI) -> nsepseq(statement,SEMI)
##

Ill-formed block of statements.
At this point, if the statement is complete, one of the following is
expected:
  * a semicolon ';' followed by another statement (instruction or
    declaration);
  * the keyword 'end' if the block is complete.

interactive_expr: Begin Var Ident ASS With
##
## Ends in an error in state: 278.
##
## unqualified_decl(ASS) -> core_pattern ASS . expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern ASS
##

Ill-formed variable declaration.
At this point, an expression is expected, whose value is the initial
value of the variable being defined.

interactive_expr: Begin Var Ident COLON UIdent ARROW
##
## Ends in an error in state: 378.
##
## unqualified_decl(ASS) -> core_pattern type_annotation . ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 24, spurious reduction of production variant -> UIdent
## In state 43, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 55, spurious reduction of production type_expr -> sum_type
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
##

Ill-formed variable declaration.
At this point, if the type annotation is complete, the assignment
symbol ':=' is expected, followed by the expression whose value is
the initial value of the variable being defined.

interactive_expr: Begin Var Ident With
##
## Ends in an error in state: 277.
##
## unqualified_decl(ASS) -> core_pattern . ASS expr [ SEMI RBRACE End ]
## unqualified_decl(ASS) -> core_pattern . type_annotation ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern
##

Ill-formed variable declaration.
At this point, one of the following is expected:
  * a type annotation introduced by a colon ':';
  * the assignment symbol ':=' followed by an expression whose
    value is the initial value of the variable being defined.

interactive_expr: Begin Var With
##
## Ends in an error in state: 200.
##
## var_decl -> Var . unqualified_decl(ASS) [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## Var
##

Ill-formed variable declaration.
At this point, a variable name is expected.

interactive_expr: Begin While With
##
## Ends in an error in state: 163.
##
## while_loop -> While . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## While
##

Ill-formed general loop.
At this point, the condition is expected as an expression.

interactive_expr: BigMap LBRACKET With
##
## Ends in an error in state: 160.
##
## terse_inj(BigMap,binding) -> BigMap LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(BigMap,binding) -> BigMap LBRACKET . sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap LBRACKET
##

Ill-formed big_map expression.
At this point, one of the following is expected:
  * key/value bindings separated by semicolons ';' and concluded by a
    closing bracket ']';
  * a closing bracket ']' if the big_map is empty.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: BigMap With
##
## Ends in an error in state: 159.
##
## terse_inj(BigMap,binding) -> BigMap . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(BigMap,binding) -> BigMap . LBRACKET sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(BigMap,binding) -> BigMap . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(BigMap,binding) -> BigMap . sep_or_term_list(binding,SEMI) End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap
##

Ill-formed big_map expression.
At this point, one of the following is expected:
  * key/value bindings separated by semicolons ';' and concluded by
    the keyword 'end';
  * an opening bracket '[' followed by key/value bindings,
    or none (empty big_map), and a closing bracket ']';
  * the keyword 'end' if the big_map is empty.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Block LBRACE Skip With
##
## Ends in an error in state: 626.
##
## terse_block -> option(Block) LBRACE sep_or_term_list(statement,SEMI) . RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## option(Block) LBRACE sep_or_term_list(statement,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 620, spurious reduction of production nsepseq(statement,SEMI) -> statement
## In state 629, spurious reduction of production sep_or_term_list(statement,SEMI) -> nsepseq(statement,SEMI)
##

Ill-formed block of statements.
At this point, if the statement is complete, a closing brace '}' is
expected.

interactive_expr: Block With
##
## Ends in an error in state: 198.
##
## terse_block -> option(Block) . LBRACE sep_or_term_list(statement,SEMI) RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## option(Block)
##

Ill-formed block of statements.
At this point, an opening brace '{' is expected, followed by
statements (instructions and declarations) separated or terminated by
semicolons ';', and concluded by a closing brace '}'.

interactive_expr: Case Verbatim Of UIdent LPAR With
##
## Ends in an error in state: 202.
##
## par(tuple(pattern)) -> LPAR . tuple(pattern) RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed tuple of patterns.
At this point, the first component is expected as a pattern.

interactive_expr: Case Verbatim Of LBRACKET With
##
## Ends in an error in state: 653.
##
## terse_case(expr) -> Case expr Of LBRACKET option(VBAR) . cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET option(VBAR)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 652, spurious reduction of production option(VBAR) ->
##
interactive_expr: Case Verbatim Of With
##
## Ends in an error in state: 663.
##
## verb_case(expr) -> Case expr Of option(VBAR) . cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of option(VBAR)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 651, spurious reduction of production option(VBAR) ->
##
interactive_expr: Case Verbatim Of WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 661.
##
## nsepseq(case_clause(expr),VBAR) -> case_clause(expr) VBAR . nsepseq(case_clause(expr),VBAR) [ RBRACKET End ]
##
## The known suffix of the stack is as follows:
## case_clause(expr) VBAR
##

Ill-formed case expression.
At this point, a case clause is expected, made of a pattern and an
expression separated by an arrow '->'.

interactive_expr: Case Verbatim Of LPAR WILD COMMA With
##
## Ends in an error in state: 229.
##
## tuple(pattern) -> pattern COMMA . nsepseq(pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern COMMA
##

Ill-formed tuple of patterns in a case expression.
At this point, a tuple component is expected as a pattern.

interactive_expr: Case Verbatim Of LPAR WILD SHARP Bytes With
##
## Ends in an error in state: 227.
##
## par(pattern) -> LPAR pattern . RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## tuple(pattern) -> pattern . COMMA nsepseq(pattern,COMMA) [ RPAR ]
## typed_pattern -> pattern . type_annotation [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 244, spurious reduction of production nsepseq(core_pattern,SHARP) -> core_pattern
## In state 243, spurious reduction of production pattern -> core_pattern SHARP nsepseq(core_pattern,SHARP)
##

Ill-formed case expression.
At this point, if the list pattern is complete, a closing parenthesis
')' is expected.

interactive_expr: Case Verbatim Of LPAR With
##
## Ends in an error in state: 213.
##
## par(pattern) -> LPAR . pattern RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## par(tuple(pattern)) -> LPAR . tuple(pattern) RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## par(typed_pattern) -> LPAR . typed_pattern RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed list pattern.
At this point, a pattern matching non-empty lists is expected.

interactive_expr: Case Verbatim Of List LBRACKET WILD With
##
## Ends in an error in state: 251.
##
## terse_inj(List,core_pattern) -> List LBRACKET sep_or_term_list(core_pattern,SEMI) . RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET sep_or_term_list(core_pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production nsepseq(core_pattern,SEMI) -> core_pattern
## In state 254, spurious reduction of production sep_or_term_list(core_pattern,SEMI) -> nsepseq(core_pattern,SEMI)
##

Ill-formed list of patterns.
At this point, if pattern matching a list element is complete, one of
the following is expected:
  * a semicolon ';' followed by another pattern;
  * a closing bracket ']' if the list is complete.

interactive_expr: Case Verbatim Of List LBRACKET With
##
## Ends in an error in state: 249.
##
## terse_inj(List,core_pattern) -> List LBRACKET . RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## terse_inj(List,core_pattern) -> List LBRACKET . sep_or_term_list(core_pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET
##

Ill-formed list of patterns.
At this point, one of the following is expected:
  * patterns matching list elements and separated by semicolons ';';
  * a closing bracket ']' if matching the empty list.

interactive_expr: Case Verbatim Of List With
##
## Ends in an error in state: 212.
##
## terse_inj(List,core_pattern) -> List . LBRACKET RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## terse_inj(List,core_pattern) -> List . LBRACKET sep_or_term_list(core_pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## verb_inj(List,core_pattern) -> List . End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## verb_inj(List,core_pattern) -> List . sep_or_term_list(core_pattern,SEMI) End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List
##

Ill-formed list of patterns.
At this point, one of the following is expected:
  * patterns matching list elements, separated by semicolons ';';
  * an opening bracket '[' followed by patterns separated by
    semicolons ';', and a closing bracket ']';
  * the brackets '[]' or the keyword 'end' if matching the empty list.

interactive_expr: Case Verbatim Of WILD ARROW With
##
## Ends in an error in state: 655.
##
## case_clause(expr) -> pattern ARROW . expr [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

Ill-formed clause of a case expression.
At this point, the right-hand side of the clause is expected as an
expression.
Note: A clause, here, is made of a pattern and an expression separated
by an arrow '->'.

interactive_expr: Case Verbatim Of WILD SHARP WILD SHARP With
##
## Ends in an error in state: 245.
##
## nsepseq(core_pattern,SHARP) -> core_pattern SHARP . nsepseq(core_pattern,SHARP) [ RPAR COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern SHARP
##
interactive_expr: Case Verbatim Of WILD SHARP With
##
## Ends in an error in state: 242.
##
## pattern -> core_pattern SHARP . nsepseq(core_pattern,SHARP) [ RPAR COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern SHARP
##

Ill-formed list of patterns.
At this point, a pattern matching a non-empty list is expected.

interactive_expr: Case Verbatim Of WILD With
##
## Ends in an error in state: 654.
##
## case_clause(expr) -> pattern . ARROW expr [ VBAR RBRACKET End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 241, spurious reduction of production pattern -> core_pattern
##

Ill-formed case clause.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by the right-hand side as an expression.

interactive_expr: Case With
##
## Ends in an error in state: 156.
##
## terse_case(expr) -> Case . expr Of LBRACKET option(VBAR) cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## verb_case(expr) -> Case . expr Of option(VBAR) cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case
##

Ill-formed case expression.
At this point, the condition is expected as an expression.

interactive_expr: UIdent DOT With
##
## Ends in an error in state: 382.
##
## module_path(field_path) -> UIdent DOT . module_path(field_path) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(field_path) -> UIdent DOT . field_path [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## value_in_module -> UIdent DOT . Or [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## value_in_module -> UIdent DOT . And [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a value from a module.
At this point, the qualified name of a value is expected.

interactive_expr: Function LPAR Const Ident RPAR COLON Ident With
##
## Ends in an error in state: 666.
##
## fun_expr(expr) -> Function parameters type_annotation . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production cartesian_level -> core_type
## In state 74, spurious reduction of production fun_type_level -> cartesian_level
## In state 66, spurious reduction of production type_expr -> fun_type_level
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
##

Ill-formed function expression.
At this point, the keyword 'is' is expected, followed with the
function body as an expression or a block of statements (instructions
or declarations) ending with an expression.
Note: A block, in this context, is delimited by 'block {' and '} with'.

interactive_expr: Function LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 155.
##
## fun_expr(expr) -> Function parameters Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters Is
##
interactive_expr: If UIdent Then Function LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 484.
##
## fun_expr(closed_expr) -> Function parameters Is . closed_expr [ Else ]
## fun_expr(expr) -> Function parameters Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters Is
##
interactive_expr: If UIdent Then Function LPAR Const Ident RPAR COLON Ident Is With
##
## Ends in an error in state: 497.
##
## fun_expr(closed_expr) -> Function parameters type_annotation Is . closed_expr [ Else ]
## fun_expr(expr) -> Function parameters type_annotation Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters type_annotation Is
##

Ill-formed function expression.
At this point, the body is expected as an expression.

interactive_expr: Function LPAR Const Ident RPAR With
##
## Ends in an error in state: 154.
##
## fun_expr(expr) -> Function parameters . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function parameters . type_annotation Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters
##
contract: Attr Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 445.
##
## fun_decl -> nseq(Attr) Function Ident parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Function Ident parameters . type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function Ident parameters
##

Ill-formed function expression.
At this point, one of the following is expected:
  * a type annotation for the returned value;
  * the keyword 'is' followed by the function body as an expression.

interactive_expr: Function LPAR Const Ident With
##
## Ends in an error in state: 111.
##
## param_decl -> param_kind var_pattern . [ SEMI RPAR ]
## param_decl -> param_kind var_pattern . param_type [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## param_kind var_pattern
##

Ill-formed function parameter declaration.
At this point, one of the following is expected:
  * a type annotation starting with a colon ':';
  * a semicolon ';' followed with another parameter declaration;
  * a closing parenthesis ')' if no more parameters.

interactive_expr: Function LPAR Var Ident COLON String With
##
## Ends in an error in state: 120.
##
## par(nsepseq(param_decl,SEMI)) -> LPAR nsepseq(param_decl,SEMI) . RPAR [ Is COLON ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(param_decl,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production cartesian_level -> core_type
## In state 74, spurious reduction of production fun_type_level -> cartesian_level
## In state 113, spurious reduction of production param_type -> COLON fun_type_level
## In state 114, spurious reduction of production param_decl -> param_kind var_pattern param_type
## In state 117, spurious reduction of production nsepseq(param_decl,SEMI) -> param_decl
##

Ill-formed function parameter declaration.
At this point, if the parameter declaration is complete, a closing
parenthesis ')' is expected.

interactive_expr: Function LPAR Var Ident COLON With
##
## Ends in an error in state: 112.
##
## param_type -> COLON . fun_type_level [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed function parameter type.
At this point, a type is expected.

interactive_expr: Function LPAR Var Ident SEMI With
##
## Ends in an error in state: 118.
##
## nsepseq(param_decl,SEMI) -> param_decl SEMI . nsepseq(param_decl,SEMI) [ RPAR ]
##
## The known suffix of the stack is as follows:
## param_decl SEMI
##

Ill-formed function parameters.
At this point, a function parameter declaration is expected.

interactive_expr: Function LPAR Var With
##
## Ends in an error in state: 108.
##
## param_decl -> param_kind . var_pattern [ SEMI RPAR ]
## param_decl -> param_kind . var_pattern param_type [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## param_kind
##

Ill-formed function parameter declaration.
At this point, one of the following is expected:
  * attributes for the parameter;
  * the parameter as a variable.

interactive_expr: Function LPAR With
##
## Ends in an error in state: 105.
##
## par(nsepseq(param_decl,SEMI)) -> LPAR . nsepseq(param_decl,SEMI) RPAR [ Is COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function parameter declaration.
At this point, a parameter declaration is expected.

interactive_expr: Function With
##
## Ends in an error in state: 153.
##
## fun_expr(expr) -> Function . parameters Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function . parameters type_annotation Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function
##

Ill-formed function expression.
At this point, parameter declarations are expected between parentheses.

contract: Function With
##
## Ends in an error in state: 412.
##
## fun_decl -> Function . Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function . Ident parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function
##
contract: Recursive Function With
##
## Ends in an error in state: 103.
##
## fun_decl -> Recursive Function . Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function . Ident parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function
##
contract: Attr Function With
##
## Ends in an error in state: 443.
##
## fun_decl -> nseq(Attr) Function . Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Function . Ident parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function
##
contract: Attr Recursive Function With
##
## Ends in an error in state: 435.
##
## fun_decl -> nseq(Attr) Recursive Function . Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Recursive Function . Ident parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function
##

Ill-formed function declaration.
At this point, the name of the function is expected.

interactive_expr: Ident LBRACKET With
##
## Ends in an error in state: 188.
##
## brackets(expr) -> LBRACKET . expr RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed map lookup.
At this point, a key is expected as an expression.

interactive_expr: Ident LPAR Verbatim COMMA With
##
## Ends in an error in state: 680.
##
## nsepseq(expr,COMMA) -> expr COMMA . nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Ill-formed tuple expression.
At this point, another component is expected as an expression.

interactive_expr: Ident LPAR With
##
## Ends in an error in state: 126.
##
## par(nsepseq(expr,COMMA)) -> LPAR . nsepseq(expr,COMMA) RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function call.
At this point, an argument is expected as an expression.

interactive_expr: Ident While
##
## Ends in an error in state: 744.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 145, spurious reduction of production field_path -> Ident
## In state 293, spurious reduction of production local_path -> field_path
## In state 286, spurious reduction of production path_expr -> local_path
## In state 187, spurious reduction of production core_expr -> path_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed map lookup or record update.
At this point, if the name is fully qualified, one of the following is
expected:
  * if the name denotes a map, then a key as an expression between
    brackets '[' and ']';
  * if the name denotes a record, then the keyword 'with', followed by
    a record (update)

interactive_expr: Ident With Record Ident EQ Bytes SEMI With
##
## Ends in an error in state: 372.
##
## verb_inj(Record,field_path_assignment) -> Record sep_or_term_list(field_path_assignment,SEMI) . End [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record sep_or_term_list(field_path_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 306, spurious reduction of production nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI
## In state 303, spurious reduction of production sep_or_term_list(field_path_assignment,SEMI) -> nseq(__anonymous_0(field_path_assignment,SEMI))
##

Ill-formed record update.
At this point, if the field update is complete, one of the following
is expected:
  * a semicolon ';' followed by another field update (assignment);
  * the keyword 'end' if the record update is complete.

interactive_expr: Ident With Record Ident With
##
## Ends in an error in state: 309.
##
## field_path_assignment -> field_path . EQ expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## field_path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 145, spurious reduction of production field_path -> Ident
##

Ill-formed record update.
At this point, if the field to update is fully qualified, the symbol
'=' is expected, followed by an expression whose value is the new
value of the field.

interactive_expr: Ident With Record LBRACKET With
##
## Ends in an error in state: 299.
##
## terse_inj(Record,field_path_assignment) -> Record LBRACKET . RBRACKET [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Record,field_path_assignment) -> Record LBRACKET . sep_or_term_list(field_path_assignment,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record update.
At this point, a field assignment (update) is expected.

interactive_expr: Ident With Record With
##
## Ends in an error in state: 298.
##
## terse_inj(Record,field_path_assignment) -> Record . LBRACKET RBRACKET [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Record,field_path_assignment) -> Record . LBRACKET sep_or_term_list(field_path_assignment,SEMI) RBRACKET [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Record,field_path_assignment) -> Record . End [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Record,field_path_assignment) -> Record . sep_or_term_list(field_path_assignment,SEMI) End [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed record update.
At this point, one of the following is expected:
  * a series of field assignments (updates), separated by semicolons ';';
  * an opening bracket '[' followed by field assignments and a closing
    bracket ']'.

interactive_expr: Ident With With
##
## Ends in an error in state: 297.
##
## record_update -> core_expr With . injection(Record,field_path_assignment) [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## core_expr With
##

Ill-formed record update.
At this point, a record is expected, starting with the keyword
'record'.

interactive_expr: If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 671.
##
## if_then_else_expr(expr) -> If expr Then closed_expr Else . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 502.
##
## if_then_else_expr(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
## if_then_else_expr(expr) -> If expr Then closed_expr Else . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##

Ill-formed conditional expression.
At this point, the contents of the 'else' branch is expected as an
expression.

interactive_expr: If Verbatim Then With
##
## Ends in an error in state: 669.
##
## if_then_else_expr(expr) -> If expr Then . closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If expr Then . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If UIdent Then If UIdent Then With
##
## Ends in an error in state: 481.
##
## if_then_else_expr(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
## if_then_else_expr(expr) -> If expr Then . closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If expr Then . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

Ill-formed conditional expression.
At this point, the contents of the 'then' branch is expected as an
expression.

interactive_expr: LPAR Verbatim COLON Ident With
##
## Ends in an error in state: 672.
##
## par(typed_expr) -> LPAR typed_expr . RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR typed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production cartesian_level -> core_type
## In state 74, spurious reduction of production fun_type_level -> cartesian_level
## In state 66, spurious reduction of production type_expr -> fun_type_level
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
## In state 683, spurious reduction of production typed_expr -> disj_expr_level type_annotation
##

Ill-formed annotated expression.
At this point, if the type annotation is complete, a closing
parenthesis ')' is expected.

interactive_expr: LPAR Verbatim COMMA With
##
## Ends in an error in state: 677.
##
## tuple(expr) -> expr COMMA . nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Ill-formed tuple expression.
At this point, a tuple component is expected as an expression.

interactive_expr: LPAR With
##
## Ends in an error in state: 142.
##
## par(expr) -> LPAR . expr RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive DOT Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## par(tuple(expr)) -> LPAR . tuple(expr) RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## par(typed_expr) -> LPAR . typed_expr RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed expression.
At this point, an expression is expected, denoting either
  * an expression annotated with its type,
  * a parenthesised expression,
  * a tuple component.

interactive_expr: Lang With
##
## Ends in an error in state: 141.
##
## code_inj -> Lang . expr RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Lang
##

Ill-formed code injection.
At this point, the code is expected as an expression whose value is a
verbatim string.

interactive_expr: List LBRACKET With
##
## Ends in an error in state: 686.
##
## terse_inj(List,expr) -> List LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(List,expr) -> List LBRACKET . sep_or_term_list(expr,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET
##

Ill-formed list of expressions.
At this point, one of the following is expected:
  * list elements as expressions separated by semicolons ';';
  * a closing bracket ']' if the list is empty.

interactive_expr: List With
##
## Ends in an error in state: 140.
##
## terse_inj(List,expr) -> List . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(List,expr) -> List . LBRACKET sep_or_term_list(expr,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(List,expr) -> List . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(List,expr) -> List . sep_or_term_list(expr,SEMI) End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## List
##

Ill-formed list of expressions.
At this point, one of the following is expected:
  * the brackets '[]' or the keyword 'end' if the list is empty;
  * list elements as expressions separated by semicolons ';';
  * as the previous case, but enclosed between brackets '[' and ']'.

contract: Const Record Ident EQ With
##
## Ends in an error in state: 209.
##
## field_pattern -> Ident EQ . core_pattern [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed record constant declaration.
At this point a pattern is expected.

contract: Const Record Ident With
##
## Ends in an error in state: 272.
##
## verb_inj(Record,field_pattern) -> Record sep_or_term_list(field_pattern,SEMI) . End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record sep_or_term_list(field_pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 208, spurious reduction of production field_pattern -> Ident
## In state 267, spurious reduction of production nsepseq(field_pattern,SEMI) -> field_pattern
## In state 266, spurious reduction of production sep_or_term_list(field_pattern,SEMI) -> nsepseq(field_pattern,SEMI)
##

Ill-formed record constant declaration.
At this point, if the current field pattern is complete, one of the following is expected:
  * the keyword 'end' if the record is complete;
  * another field pattern.

contract: Const Record LBRACKET Ident EQ Bytes End
##
## Ends in an error in state: 263.
##
## terse_inj(Record,field_pattern) -> Record LBRACKET sep_or_term_list(field_pattern,SEMI) . RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 267, spurious reduction of production nsepseq(field_pattern,SEMI) -> field_pattern
## In state 266, spurious reduction of production sep_or_term_list(field_pattern,SEMI) -> nsepseq(field_pattern,SEMI)
##

Ill-formed record constant declaration.
At this point, if the pattern is complete, a closing bracket ']' is expected.

contract: Const Record LBRACKET With
##
## Ends in an error in state: 206.
##
## terse_inj(Record,field_pattern) -> Record LBRACKET . RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## terse_inj(Record,field_pattern) -> Record LBRACKET . sep_or_term_list(field_pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record constant declaration.
At this point one of the following is expected:
  * a field pattern;
  * closing bracket.

contract: Const Record With
##
## Ends in an error in state: 204.
##
## terse_inj(Record,field_pattern) -> Record . LBRACKET RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## terse_inj(Record,field_pattern) -> Record . LBRACKET sep_or_term_list(field_pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## verb_inj(Record,field_pattern) -> Record . End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
## verb_inj(Record,field_pattern) -> Record . sep_or_term_list(field_pattern,SEMI) End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed record constant declaration.
At this point one of the following is expected:
  * a list of semicolon ';' separated field patterns;
  * an opening bracket '[', followed by semicolon separated ';' field patterns.
  * the closing 'end' keyword.

interactive_expr: MINUS With
##
## Ends in an error in state: 139.
##
## unary_op(MINUS,update_expr_level) -> MINUS . update_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Ill-formed unary expression.
At this point, an expression is expected.

interactive_expr: Map LBRACKET With
##
## Ends in an error in state: 700.
##
## terse_inj(Map,binding) -> Map LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Map,binding) -> Map LBRACKET . sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Map LBRACKET
##

Ill-formed map expression.
At this point, one of the following is expected:
  * key/value bindings separated by semicolons ';';
  * a closing bracket ']' if the map is empty.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Map Verbatim ARROW With
##
## Ends in an error in state: 641.
##
## binding -> expr ARROW . expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## expr ARROW
##

Ill-formed key/value binding in a map.
At this point, the value is expected as an expression.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Map With
##
## Ends in an error in state: 138.
##
## terse_inj(Map,binding) -> Map . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Map,binding) -> Map . LBRACKET sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Map,binding) -> Map . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Map,binding) -> Map . sep_or_term_list(binding,SEMI) End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Map
##

Ill-formed map expression.
At this point, one of the following is expected:
  * the brackets '[]' or the keyword 'end' if the map is empty;
  * key/value bindings separated by semicolons ';';
  * as the previous case, but enclosed between brackets '[' and ']'.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Not With
##
## Ends in an error in state: 134.
##
## unary_op(Not,update_expr_level) -> Not . update_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Not
##

Ill-formed unary expression.
At this point, an expression is expected.

interactive_expr: Ident With Record Ident EQ With
##
## Ends in an error in state: 310.
##
## field_path_assignment -> field_path EQ . expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## field_path EQ
##
interactive_expr: Record Ident EQ With
##
## Ends in an error in state: 133.
##
## field_assignment -> Ident EQ . expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed record field assignment.
At this point, an expression is expected, whose value is that of the
field.

interactive_expr: Record LBRACKET With
##
## Ends in an error in state: 130.
##
## terse_inj(Record,field_assignment) -> Record LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Record,field_assignment) -> Record LBRACKET . sep_or_term_list(field_assignment,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record expression.
At this point, field assignments separated by semicolons ';' are
expected.

interactive_expr: Set LBRACKET With
##
## Ends in an error in state: 720.
##
## terse_inj(Set,expr) -> Set LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Set,expr) -> Set LBRACKET . sep_or_term_list(expr,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Set LBRACKET
##

Ill-formed set expression.
At this point, one of the following is expected:
  * set elements separated by semicolons ';';
  * a closing bracket ']' if the set is empty.

interactive_expr: Set With
##
## Ends in an error in state: 128.
##
## terse_inj(Set,expr) -> Set . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## terse_inj(Set,expr) -> Set . LBRACKET sep_or_term_list(expr,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Set,expr) -> Set . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## verb_inj(Set,expr) -> Set . sep_or_term_list(expr,SEMI) End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Set
##

Ill-formed set expression.
At this point, one of the following is expected:
  * the brackets '[]' or the keyword 'end' if the set is empty;
  * set elements (expressions) separated by semicolons ';';
  * as the previous case, but enclosed between brackets '[' and ']'.

interactive_expr: Verbatim CARET With
##
## Ends in an error in state: 318.
##
## bin_op(cons_expr_level,CARET,cat_expr_level) -> cons_expr_level CARET . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## cons_expr_level CARET
##

Ill-formed string expression.
At this point, an expression is expected.

interactive_expr: Verbatim SHARP With
##
## Ends in an error in state: 331.
##
## bin_op(add_expr_level,SHARP,cons_expr_level) -> add_expr_level SHARP . cons_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr_level SHARP
##

Ill-formed list expression.
At this point, an expression denoting a list is expected.

interactive_expr: Verbatim Contains With
##
## Ends in an error in state: 173.
##
## set_mem_level -> update_expr_level Contains . set_mem_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Module LBRACE Function From End Else EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## update_expr_level Contains
##

Ill-formed membership test in a set.
At this point, an expression denoting a set element is expected.

interactive_expr: Verbatim And With
##
## Ends in an error in state: 342.
##
## conj_expr_level -> conj_expr_level And . set_mem_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Module LBRACE Function From End Else EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## conj_expr_level And
##
interactive_expr: Verbatim Or With
##
## Ends in an error in state: 316.
##
## disj_expr_level -> disj_expr_level Or . conj_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Module LBRACE Function From End Else EOF Directive Const COMMA COLON Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## disj_expr_level Or
##

Ill-formed Boolean expression.
At this point, a Boolean expression is expected.

interactive_expr: Verbatim EQ With
##
## Ends in an error in state: 355.
##
## bin_op(comp_expr_level,EQ,cat_expr_level) -> comp_expr_level EQ . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ
##
interactive_expr: Verbatim NE With
##
## Ends in an error in state: 345.
##
## bin_op(comp_expr_level,NE,cat_expr_level) -> comp_expr_level NE . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##
interactive_expr: Verbatim GE With
##
## Ends in an error in state: 353.
##
## bin_op(comp_expr_level,GE,cat_expr_level) -> comp_expr_level GE . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GE
##
interactive_expr: Verbatim GT With
##
## Ends in an error in state: 351.
##
## bin_op(comp_expr_level,GT,cat_expr_level) -> comp_expr_level GT . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GT
##
interactive_expr: Verbatim LE With
##
## Ends in an error in state: 349.
##
## bin_op(comp_expr_level,LE,cat_expr_level) -> comp_expr_level LE . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##
interactive_expr: Verbatim LT With
##
## Ends in an error in state: 347.
##
## bin_op(comp_expr_level,LT,cat_expr_level) -> comp_expr_level LT . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##

Ill-formed Boolean expression.
At this point, an expression is expected.

interactive_expr: Verbatim MINUS With
##
## Ends in an error in state: 339.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ VBAR Type To Then Step SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##
interactive_expr: Verbatim Mod With
##
## Ends in an error in state: 337.
##
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level Mod . unary_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Mod
##
interactive_expr: Verbatim PLUS With
##
## Ends in an error in state: 333.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ VBAR Type To Then Step SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##
interactive_expr: Verbatim SLASH With
##
## Ends in an error in state: 335.
##
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level SLASH . unary_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##
interactive_expr: Verbatim TIMES With
##
## Ends in an error in state: 280.
##
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level TIMES . unary_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##

Ill-formed arithmetic expression.
At this point, an expression is expected.

interactive_expr: With
##
## Ends in an error in state: 742.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed expression.

contract: Const Ident EQ With
##
## Ends in an error in state: 424.
##
## unqualified_decl(EQ) -> core_pattern EQ . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern EQ
##
contract: Const Ident COLON UIdent EQ With
##
## Ends in an error in state: 427.
##
## unqualified_decl(EQ) -> core_pattern type_annotation EQ . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern type_annotation EQ
##

Ill-formed constant declaration.
At this point, an expression is expected, whose value is that of the
constant.

contract: Const Ident With
##
## Ends in an error in state: 423.
##
## unqualified_decl(EQ) -> core_pattern . EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## unqualified_decl(EQ) -> core_pattern . type_annotation EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern
##

Ill-formed constant declaration.
At this point, one of the following is expected:
  * a type annotation starting with a colon ':';
  * the symbol '=' followed by an expression whose value is that of
    the constant being defined.

contract: Const With
##
## Ends in an error in state: 421.
##
## const_decl -> Const . unqualified_decl(EQ) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Const
##
contract: Attr Const With
##
## Ends in an error in state: 451.
##
## const_decl -> nseq(Attr) Const . unqualified_decl(EQ) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Const
##

Ill-formed constant declaration.
At this point, the name of the constant is expected.

contract: Function Ident LPAR Const Ident RPAR COLON Ident With
##
## Ends in an error in state: 417.
##
## fun_decl -> Function Ident parameters type_annotation . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production cartesian_level -> core_type
## In state 74, spurious reduction of production fun_type_level -> cartesian_level
## In state 66, spurious reduction of production type_expr -> fun_type_level
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
##
contract: Recursive Function Ident LPAR Const Ident RPAR COLON String With
##
## Ends in an error in state: 731.
##
## fun_decl -> Recursive Function Ident parameters type_annotation . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production cartesian_level -> core_type
## In state 74, spurious reduction of production fun_type_level -> cartesian_level
## In state 66, spurious reduction of production type_expr -> fun_type_level
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
##
contract: Attr Recursive Function Ident LPAR Const Ident RPAR COLON UIdent With
##
## Ends in an error in state: 440.
##
## fun_decl -> nseq(Attr) Recursive Function Ident parameters type_annotation . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function Ident parameters type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 24, spurious reduction of production variant -> UIdent
## In state 43, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 55, spurious reduction of production type_expr -> sum_type
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
##
contract: Attr Function Ident LPAR Const Ident RPAR COLON UIdent With
##
## Ends in an error in state: 448.
##
## fun_decl -> nseq(Attr) Function Ident parameters type_annotation . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function Ident parameters type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 24, spurious reduction of production variant -> UIdent
## In state 43, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 55, spurious reduction of production type_expr -> sum_type
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
##

Ill-formed function declaration.
At this point, the keyword 'is' is expected, followed by the function
body as an expression.

contract: Function Ident LPAR Const Ident RPAR COLON UIdent Is With
##
## Ends in an error in state: 418.
##
## fun_decl -> Function Ident parameters type_annotation Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters type_annotation Is
##
contract: Attr Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 446.
##
## fun_decl -> nseq(Attr) Function Ident parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function Ident parameters Is
##
contract: Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 415.
##
## fun_decl -> Function Ident parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters Is
##
contract: Recursive Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 123.
##
## fun_decl -> Recursive Function Ident parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters Is
##
contract: Attr Recursive Function Ident LPAR Const Ident RPAR COLON UIdent Is With
##
## Ends in an error in state: 441.
##
## fun_decl -> nseq(Attr) Recursive Function Ident parameters type_annotation Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function Ident parameters type_annotation Is
##
contract: Attr Function Ident LPAR Const Ident RPAR COLON UIdent Is With
##
## Ends in an error in state: 449.
##
## fun_decl -> nseq(Attr) Function Ident parameters type_annotation Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function Ident parameters type_annotation Is
##
interactive_expr: Function LPAR Const Ident RPAR COLON WILD Is With
##
## Ends in an error in state: 667.
##
## fun_expr(expr) -> Function parameters type_annotation Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters type_annotation Is
##
contract: Recursive Function Ident LPAR Const Ident RPAR COLON WILD Is With
##
## Ends in an error in state: 732.
##
## fun_decl -> Recursive Function Ident parameters type_annotation Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters type_annotation Is
##
contract: Attr Recursive Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 438.
##
## fun_decl -> nseq(Attr) Recursive Function Ident parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function Ident parameters Is
##

Ill-formed function declaration.
At this point, the function body is expected as an expression.

contract: Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 414.
##
## fun_decl -> Function Ident parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function Ident parameters . type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters
##

Ill-formed function declaration.
At this point, if the parameters are complete, one of the following is
expected:
  * a type annotation starting with a colon ':';
  * the keyword 'is' followed by the function body an expression.

contract: Function Ident With
##
## Ends in an error in state: 413.
##
## fun_decl -> Function Ident . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function Ident . parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident
##
contract: Recursive Function Ident With
##
## Ends in an error in state: 104.
##
## fun_decl -> Recursive Function Ident . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function Ident . parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident
##

Ill-formed function declaration.
At this point, the parameter declarations are expected between
parentheses.

contract: Recursive Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 122.
##
## fun_decl -> Recursive Function Ident parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function Ident parameters . type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters
##

Ill-formed function declaration.
At this point, if the paramters are complete, one of the following is
expected:
  * a type annotation for the result, starting with a colon ':';
  * the keyword 'is' followed by the function body as an expression.

contract: Recursive With
##
## Ends in an error in state: 102.
##
## fun_decl -> Recursive . Function Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive . Function Ident parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive
##
contract: Attr Recursive With
##
## Ends in an error in state: 434.
##
## fun_decl -> nseq(Attr) Recursive . Function Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Recursive . Function Ident parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive
##

Ill-formed function declaration.
At this point, the keyword 'function' is expected, followed by the name
of the function.

contract: Type Ident Is BigMap With
##
## Ends in an error in state: 37.
##
## type_ctor_app -> BigMap . type_tuple [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap
##

Ill-formed big_map type.
At this point, a pair of types is expected: the type of the keys and
the type of the values.

contract: Type Ident Is Map With
##
## Ends in an error in state: 31.
##
## type_ctor_app -> Map . type_tuple [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Map
##

Ill-formed map type.
At this point, a pair of types is expected: the type of the keys and
the type of the values.

contract: Type Ident Is UIdent DOT With
##
## Ends in an error in state: 18.
##
## module_path(type_name) -> UIdent DOT . module_path(type_name) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module LPAR Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(type_name) -> UIdent DOT . Ident [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module LPAR Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a type in a module.
At this point, the qualified name of a type is expected.

contract: Type Ident Is UIdent Of With
##
## Ends in an error in state: 16.
##
## of_type_expr -> Of . fun_type_level [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## Of
##

Ill-formed variant definition.
At this point, a type other than a sum type is expected as the
parameter of the constructor.
Note: If you want a sum type, use parentheses.

contract: Type Ident Is UIdent VBAR With
##
## Ends in an error in state: 44.
##
## nsepseq(variant,VBAR) -> variant VBAR . nsepseq(variant,VBAR) [ Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## variant VBAR
##
contract: Type Ident Is VBAR With
##
## Ends in an error in state: 14.
##
## sum_type -> VBAR . nsepseq(variant,VBAR) [ Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed variant type.
At this point, a variant is expected, starting with a data constructor.

contract: Type Ident Is WILD TIMES UIdent With
##
## Ends in an error in state: 17.
##
## module_path(type_name) -> UIdent . DOT module_path(type_name) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module LPAR Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(type_name) -> UIdent . DOT Ident [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module LPAR Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a type in a module.
At this point, the selection symbol '.' is expected, followed by the
qualified name of a type.

contract: Type Ident Is With
##
## Ends in an error in state: 12.
##
## type_decl -> Type Ident option(type_params) Is . type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident option(type_params) Is
##

Ill-formed type declaration.
At this point, a type expression is expected.

contract: Type Ident Is LPAR With
##
## Ends in an error in state: 23.
##
## par(type_expr) -> LPAR . type_expr RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

At this point, a type expression is expected, follwed by a closing
parenthesis ')'.

contract: Type Ident Is LPAR String With
##
## Ends in an error in state: 96.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production cartesian_level -> core_type
## In state 74, spurious reduction of production fun_type_level -> cartesian_level
## In state 66, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed parenthesised type expression.
At this point, if the type expression is complete, a closing
parenthesis ')' is expected.

contract: Type Ident Is List With
##
## Ends in an error in state: 33.
##
## type_ctor_app -> List . par(type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List
##

Ill-formed list type.
At this point, a parenthesised type is expected, which is the type of
the list elements.

contract: Type Ident Is Map LPAR String With
##
## Ends in an error in state: 77.
##
## par(nsepseq(type_expr,COMMA)) -> LPAR nsepseq(type_expr,COMMA) . RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(type_expr,COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production cartesian_level -> core_type
## In state 74, spurious reduction of production fun_type_level -> cartesian_level
## In state 66, spurious reduction of production type_expr -> fun_type_level
## In state 51, spurious reduction of production nsepseq(type_expr,COMMA) -> type_expr
##

Ill-formed tuple of types.
At this point, if the type expression is complete, one of the
following is expected:
  * a comma ',' followed by another type expression (component);
  * a closing parenthesis ')' if the type tuple is complete.

contract: Type Ident Is Record Ident COLON Ident With
##
## Ends in an error in state: 94.
##
## verb_inj(Record,field_decl) -> Record sep_or_term_list(field_decl,SEMI) . End [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record sep_or_term_list(field_decl,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production cartesian_level -> core_type
## In state 74, spurious reduction of production fun_type_level -> cartesian_level
## In state 66, spurious reduction of production type_expr -> fun_type_level
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
## In state 81, spurious reduction of production field_decl -> Ident type_annotation
## In state 89, spurious reduction of production nsepseq(field_decl,SEMI) -> field_decl
## In state 88, spurious reduction of production sep_or_term_list(field_decl,SEMI) -> nsepseq(field_decl,SEMI)
##

Ill-formed record type.
At this point, if the field declaration is complete, one of the
following is expected:
  * a semicolon ';' followed by another field;
  * the keyword 'end' if the record is complete.

contract: Type Ident Is Record Ident COLON With
##
## Ends in an error in state: 30.
##
## type_annotation -> COLON . type_expr [ SEMI RPAR RBRACKET Is End EQ ASS ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.
At this point, a type expression is expected.

contract: Type Ident Is Record LBRACKET Ident COLON Ident With
##
## Ends in an error in state: 82.
##
## terse_inj(Record,field_decl) -> Record LBRACKET sep_or_term_list(field_decl,SEMI) . RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_decl,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 67, spurious reduction of production cartesian_level -> core_type
## In state 74, spurious reduction of production fun_type_level -> cartesian_level
## In state 66, spurious reduction of production type_expr -> fun_type_level
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
## In state 81, spurious reduction of production field_decl -> Ident type_annotation
## In state 89, spurious reduction of production nsepseq(field_decl,SEMI) -> field_decl
## In state 88, spurious reduction of production sep_or_term_list(field_decl,SEMI) -> nsepseq(field_decl,SEMI)
##

Ill-formed record type.
At this point, if the field declaration is complete, one of the
following is expected:
  * a semicolon ';' followed by another field;
  * a closing bracket ']' if the record type is complete.

contract: Type Ident Is Set With
##
## Ends in an error in state: 22.
##
## type_ctor_app -> Set . par(type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Set
##

Ill-formed set type.
At this point, the type of the set elements is expected between
parentheses.

contract: Type Ident Is String ARROW With
##
## Ends in an error in state: 75.
##
## fun_type_level -> cartesian_level ARROW . fun_type_level [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## cartesian_level ARROW
##

Ill-formed function type.
At this point, the type of the function calls is expected.

contract: Type Ident Is String TIMES String TIMES With
##
## Ends in an error in state: 72.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##
contract: Type Ident Is String TIMES With
##
## Ends in an error in state: 68.
##
## cartesian_level -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

Ill-formed product of types.
At this point, a type expression is expected.

contract: Type Ident With
##
## Ends in an error in state: 2.
##
## type_decl -> Type Ident . option(type_params) Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident
##
contract: Type Ident LPAR Ident RPAR With
##
## Ends in an error in state: 11.
##
## type_decl -> Type Ident option(type_params) . Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident option(type_params)
##

Ill-formed type declaration.
At this point, the keyword 'is' is expected, followed by a type
expression.

contract: Type With
##
## Ends in an error in state: 1.
##
## type_decl -> Type . Ident option(type_params) Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point, the name of the type is expected.

contract: Type Ident Is VBAR Attr With
##
## Ends in an error in state: 45.
##
## variant -> nseq(Attr) . UIdent [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
## variant -> nseq(Attr) . UIdent of_type_expr [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed variant.
At this point, one of the following is expected:
  * the data constructor of the variant;
  * another attribute for the variant.

contract: Const Ident COLON UIdent With
##
## Ends in an error in state: 426.
##
## unqualified_decl(EQ) -> core_pattern type_annotation . EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 24, spurious reduction of production variant -> UIdent
## In state 43, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 55, spurious reduction of production type_expr -> sum_type
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
##

Ill-formed constant declaration.
At this point, if the type annotation is complete, the keyword '=' is
expected, followed by an expression.

interactive_expr: Map Verbatim ARROW Bytes SEMI With
##
## Ends in an error in state: 705.
##
## verb_inj(Map,binding) -> Map sep_or_term_list(binding,SEMI) . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Map sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 644, spurious reduction of production nseq(__anonymous_0(binding,SEMI)) -> binding SEMI
## In state 638, spurious reduction of production sep_or_term_list(binding,SEMI) -> nseq(__anonymous_0(binding,SEMI))
##

Ill-formed map expression.
At this point, if the key/value binding is complete, one of the
following is expected:
  * a semicolon ';' followed by another key/value binding;
  * the keyword 'end' if the map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Case Verbatim Of List WILD SEMI With
##
## Ends in an error in state: 260.
##
## verb_inj(List,core_pattern) -> List sep_or_term_list(core_pattern,SEMI) . End [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List sep_or_term_list(core_pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 256, spurious reduction of production nseq(__anonymous_0(core_pattern,SEMI)) -> core_pattern SEMI
## In state 253, spurious reduction of production sep_or_term_list(core_pattern,SEMI) -> nseq(__anonymous_0(core_pattern,SEMI))
##

Ill-formed list of patterns.
At this point, if pattern matching a list element is complete, one of
the following is expected:
  * a semicolon ';' followed by another pattern;
  * the keyword 'end' if the list is complete.

interactive_expr: Record Ident EQ Bytes SEMI With
##
## Ends in an error in state: 718.
##
## verb_inj(Record,field_assignment) -> Record sep_or_term_list(field_assignment,SEMI) . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record sep_or_term_list(field_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 714, spurious reduction of production nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI
## In state 711, spurious reduction of production sep_or_term_list(field_assignment,SEMI) -> nseq(__anonymous_0(field_assignment,SEMI))
##

Ill-formed record expression.
At this point, if the field assignment is complete, one of the
following is expected:
  * a semicolon ';' followed by another record field assignment;
  * a keyword 'end' if the record is complete.

contract: With
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed contract.

contract: Type Ident Is Record With
##
## Ends in an error in state: 26.
##
## terse_inj(Record,field_decl) -> Record . LBRACKET RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## terse_inj(Record,field_decl) -> Record . LBRACKET sep_or_term_list(field_decl,SEMI) RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## verb_inj(Record,field_decl) -> Record . End [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## verb_inj(Record,field_decl) -> Record . sep_or_term_list(field_decl,SEMI) End [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed record type declaration.
At this point, one of the following is expected:
  * field declarations are expected, separated by semicolons ';';
  * an opening bracket '[' followed by field declarations.
Note: A field declaration is made of a field name followed by a type
annotation.

contract: Type Ident Is Map LPAR With
##
## Ends in an error in state: 32.
##
## par(nsepseq(type_expr,COMMA)) -> LPAR . nsepseq(type_expr,COMMA) RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed type parameter.
At this point, components as type expressions are expected, separated
by commas ',' and concluded with a closing parenthesis ')'.

contract: Type Ident Is Map LPAR WILD COMMA With
##
## Ends in an error in state: 52.
##
## nsepseq(type_expr,COMMA) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##

Ill-formed type parameter.
At this point, another component is expected as a type expression.

contract: Type Ident Is Attr Recursive
##
## Ends in an error in state: 58.
##
## record_type -> nseq(Attr) . injection(Record,field_decl) [ Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## sum_type -> nseq(Attr) . VBAR nsepseq(variant,VBAR) [ Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
## variant -> nseq(Attr) . UIdent [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
## variant -> nseq(Attr) . UIdent of_type_expr [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed type.
At this point, one of the following is expected:
  * more attributes;
  * a record type declaration starting with the keyword 'record';
  * a variant starting with a constructor.

contract: Type Ident Is Attr VBAR With
##
## Ends in an error in state: 59.
##
## sum_type -> nseq(Attr) VBAR . nsepseq(variant,VBAR) [ Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) VBAR
##

Ill-formed sum type.
At this point, one of the following is expected:
  * attributes of the variant;
  * the constructor of the variant.

contract: Type Ident Is Record Attr VBAR
##
## Ends in an error in state: 85.
##
## field_decl -> nseq(Attr) . Ident [ SEMI RBRACKET End ]
## field_decl -> nseq(Attr) . Ident type_annotation [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed record type declaration.
At this point, the following is expected:
  * attributes of the field;
  * the name of the field.

contract: Type Ident Is Attr Record LBRACKET With
##
## Ends in an error in state: 27.
##
## terse_inj(Record,field_decl) -> Record LBRACKET . RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## terse_inj(Record,field_decl) -> Record LBRACKET . sep_or_term_list(field_decl,SEMI) RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record type declaration.
At this point, one of the following is expected:
  * field declarations separated by semicolons ';';
  * a closing bracket ']' if the record is empty.
Note: A field declaration is made of a field name followed by a type
annotation.

interactive_expr: Block LBRACE With
##
## Ends in an error in state: 199.
##
## terse_block -> option(Block) LBRACE . sep_or_term_list(statement,SEMI) RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## option(Block) LBRACE
##
interactive_expr: Begin With
##
## Ends in an error in state: 162.
##
## verb_block -> Begin . sep_or_term_list(statement,SEMI) End [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Begin
##

Ill-formed block.
At this point, a statements are expected, separated by semicolon ';'.
Note: A statement is either an instruction of a declaration.

contract: Attr VBAR
##
## Ends in an error in state: 433.
##
## const_decl -> nseq(Attr) . Const unqualified_decl(EQ) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) . Function Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) . Function Ident parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) . Recursive Function Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) . Recursive Function Ident parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed declaration.
At this point, one of the following is expected:
  * more attributes;
  * the keyword 'const' if defining a constant;
  * the keyword 'var' if defining a non-constant variable;
  * the keyword 'function' if defining a function;
  * the keywords 'recursive function' if defining a recursive
    function.

contract: Attr Recursive Function Ident With
##
## Ends in an error in state: 436.
##
## fun_decl -> nseq(Attr) Recursive Function Ident . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Recursive Function Ident . parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function Ident
##
contract: Attr Function Ident With
##
## Ends in an error in state: 444.
##
## fun_decl -> nseq(Attr) Function Ident . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Function Ident . parameters type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Function Ident
##

Ill-formed function declaration.
At this point, the parameters are expected, between parentheses and
separated by semicolons ';'.

contract: Attr Recursive Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 437.
##
## fun_decl -> nseq(Attr) Recursive Function Ident parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> nseq(Attr) Recursive Function Ident parameters . type_annotation Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Recursive Function Ident parameters
##

Ill-formed function declaration.
At this point, one of the following is expected:
  * the keyword 'is' followed by an expression whose value is returned;
  * a type annotation for the return value, starting with a colon ':'.

contract: Type Ident Is UIdent With
##
## Ends in an error in state: 739.
##
## contract -> nseq(top_declaration) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## nseq(top_declaration)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 24, spurious reduction of production variant -> UIdent
## In state 43, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 55, spurious reduction of production type_expr -> sum_type
## In state 101, spurious reduction of production type_decl -> Type Ident option(type_params) Is type_expr
## In state 430, spurious reduction of production declaration -> type_decl
## In state 737, spurious reduction of production option(SEMI) ->
## In state 738, spurious reduction of production top_declaration -> declaration option(SEMI)
## In state 735, spurious reduction of production nseq(top_declaration) -> top_declaration
##

Ill-formed contract.
At this point, one the following is expected:
  * another declaration;
  * the end of the file.

interactive_expr: Begin Var Ident COLON WILD ASS With
##
## Ends in an error in state: 379.
##
## unqualified_decl(ASS) -> core_pattern type_annotation ASS . expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern type_annotation ASS
##

Ill-formed variable declaration.
At this point, the initial value of the variable is expected as an
expression.

contract: Module UIdent Is Begin Type Ident Is UIdent RBRACE
##
## Ends in an error in state: 456.
##
## verb_module_decl -> Module UIdent Is Begin declarations . End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is Begin declarations
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 24, spurious reduction of production variant -> UIdent
## In state 43, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 55, spurious reduction of production type_expr -> sum_type
## In state 101, spurious reduction of production type_decl -> Type Ident option(type_params) Is type_expr
## In state 430, spurious reduction of production declaration -> type_decl
## In state 458, spurious reduction of production option(SEMI) ->
## In state 460, spurious reduction of production nseq(__anonymous_2) -> declaration option(SEMI)
## In state 432, spurious reduction of production declarations -> nseq(__anonymous_2)
##

Ill-formed module declaration.
At this point, if the module declarations are complete, the keyword
'end' is expected.

contract: Module UIdent Is Begin With
##
## Ends in an error in state: 411.
##
## verb_module_decl -> Module UIdent Is Begin . declarations End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is Begin
##
contract: Module UIdent Is LBRACE With
##
## Ends in an error in state: 464.
##
## terse_module_decl -> Module UIdent Is option(Block) LBRACE . declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is option(Block) LBRACE
##

Ill-formed module declaration.
At this point, one of the following is expected:
  * a type declaration starting with the keyword 'type';
  * a value declaration starting with the keyword 'const' or 'var';
  * a (sub)module declaration starting with the keyword 'module'.

contract: Module UIdent Is LBRACE Type Ident Is UIdent End
##
## Ends in an error in state: 465.
##
## terse_module_decl -> Module UIdent Is option(Block) LBRACE declarations . RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is option(Block) LBRACE declarations
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 24, spurious reduction of production variant -> UIdent
## In state 43, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 55, spurious reduction of production type_expr -> sum_type
## In state 101, spurious reduction of production type_decl -> Type Ident option(type_params) Is type_expr
## In state 430, spurious reduction of production declaration -> type_decl
## In state 458, spurious reduction of production option(SEMI) ->
## In state 460, spurious reduction of production nseq(__anonymous_2) -> declaration option(SEMI)
## In state 432, spurious reduction of production declarations -> nseq(__anonymous_2)
##

Ill-formed module declaration.
At this point, if the module declarations are complete, a closing
brace '}' is expected to end the module declaration.

contract: Module UIdent Is With
##
## Ends in an error in state: 407.
##
## module_alias -> Module UIdent Is . nsepseq(module_name,DOT) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## terse_module_decl -> Module UIdent Is . option(Block) LBRACE declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## verb_module_decl -> Module UIdent Is . Begin declarations End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is
##

Ill-formed module declaration.
At this point, one of the following is expected:
  * the qualified name of a module being renamed;
  * a module structure, either starting with an opening brace '{' or
    the keyword 'begin'.

contract: Module UIdent With
##
## Ends in an error in state: 406.
##
## module_alias -> Module UIdent . Is nsepseq(module_name,DOT) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## terse_module_decl -> Module UIdent . Is option(Block) LBRACE declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## verb_module_decl -> Module UIdent . Is Begin declarations End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent
##

Ill-formed module declaration.
At this point, the keyword 'is' is expected to introduce either the
qualified name of a module being renamed, or a module structure.

contract: Module With
##
## Ends in an error in state: 405.
##
## module_alias -> Module . UIdent Is nsepseq(module_name,DOT) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## terse_module_decl -> Module . UIdent Is option(Block) LBRACE declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## verb_module_decl -> Module . UIdent Is Begin declarations End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module
##

Ill-formed module declaration.
At this point, the name of the module being declared or renamed is
expected.

contract: Module UIdent Is UIdent DOT With
##
## Ends in an error in state: 409.
##
## nsepseq(module_name,DOT) -> UIdent DOT . nsepseq(module_name,DOT) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed module qualification.
At this point, a qualified module name is expected.

contract: Type Ident LPAR Ident With
##
## Ends in an error in state: 4.
##
## nsepseq(type_var,COMMA) -> Ident . [ RPAR ]
## nsepseq(type_var,COMMA) -> Ident . COMMA nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed polymorphic type declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another type parameter;
  * a closing parenthesis ')' if there are no more parameters.

contract: Type Ident LPAR With
##
## Ends in an error in state: 3.
##
## par(nsepseq(type_var,COMMA)) -> LPAR . nsepseq(type_var,COMMA) RPAR [ Is ]
##
## The known suffix of the stack is as follows:
## LPAR
##
contract: Type Ident LPAR Ident COMMA With
##
## Ends in an error in state: 5.
##
## nsepseq(type_var,COMMA) -> Ident COMMA . nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Ident COMMA
##

Ill-formed polymorphic type declaration.
At this point, a type parameter is expected.

contract: Const UIdent COLON Ident TIMES Attr With
##
## Ends in an error in state: 69.
##
## record_type -> nseq(Attr) . injection(Record,field_decl) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed record type.
At this point, if the attribute is complete, then the keyword 'record'
is expected.

contract: Const Attr With
##
## Ends in an error in state: 115.
##
## var_pattern -> nseq(Attr) . Ident [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed attributed variable.
At this point, if the attribute is complete, an identifier is
expected.

contract: Const LPAR UIdent COLON UIdent ARROW
##
## Ends in an error in state: 219.
##
## par(typed_pattern) -> LPAR typed_pattern . RPAR [ SHARP SEMI RPAR RBRACKET End EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR typed_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 24, spurious reduction of production variant -> UIdent
## In state 43, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 55, spurious reduction of production type_expr -> sum_type
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
## In state 248, spurious reduction of production typed_pattern -> pattern type_annotation
##

Ill-formed typed pattern.
At this point, if the type annotation is complete, a closing
parenthesis ')' is expected.

contract: Const LPAR UIdent COMMA UIdent With
##
## Ends in an error in state: 230.
##
## nsepseq(pattern,COMMA) -> pattern . [ RPAR ]
## nsepseq(pattern,COMMA) -> pattern . COMMA nsepseq(pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 201, spurious reduction of production ctor_app(tuple_pattern) -> UIdent
## In state 240, spurious reduction of production ctor_pattern -> ctor_app(tuple_pattern)
## In state 239, spurious reduction of production core_pattern -> ctor_pattern
## In state 241, spurious reduction of production pattern -> core_pattern
##

Ill-formed pattern of a constructor parameter.
At this point, if the pattern is complete, one of the following is
expected:
  * a comma ',' followed by another parameter as a pattern;
  * a closing parenthesis ')' if there are no more parameters.

contract: Const UIdent LPAR UIdent With
##
## Ends in an error in state: 274.
##
## tuple(pattern) -> pattern . COMMA nsepseq(pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 201, spurious reduction of production ctor_app(tuple_pattern) -> UIdent
## In state 240, spurious reduction of production ctor_pattern -> ctor_app(tuple_pattern)
## In state 239, spurious reduction of production core_pattern -> ctor_pattern
## In state 241, spurious reduction of production pattern -> core_pattern
##

Ill-formed pattern of a constructor parameter.
At this point, if the pattern is complete, a comma ',' is expected,
followed by another parameter as a pattern.

contract: Const LPAR UIdent COMMA UIdent COMMA With
##
## Ends in an error in state: 231.
##
## nsepseq(pattern,COMMA) -> pattern COMMA . nsepseq(pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern COMMA
##

Ill-formed pattern of a constructor parameter.
At this point, a parameter is expected as a pattern.

interactive_expr: UIdent With Record LBRACKET Ident EQ UIdent While
##
## Ends in an error in state: 301.
##
## terse_inj(Record,field_path_assignment) -> Record LBRACKET sep_or_term_list(field_path_assignment,SEMI) . RBRACKET [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_path_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 314, spurious reduction of production field_path_assignment -> field_path EQ expr
## In state 305, spurious reduction of production nsepseq(field_path_assignment,SEMI) -> field_path_assignment
## In state 304, spurious reduction of production sep_or_term_list(field_path_assignment,SEMI) -> nsepseq(field_path_assignment,SEMI)
##

Ill-formed record update.
At this point, if the field assignment is complete, one of the
following is expected:
  * a semicolon ';' followed by another field assignment (update);
  * a closing bracket ']' if the update is complete.

interactive_expr: UIdent DOT UIdent With
##
## Ends in an error in state: 383.
##
## module_path(field_path) -> UIdent . DOT module_path(field_path) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(field_path) -> UIdent . DOT field_path [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a value in a module.
At this point, the selection symbol '.' is expected, followed by one
of the following:
  * a sub-module name;
  * a record name;
  * a tuple name.

interactive_expr: UIdent DOT UIdent DOT With
##
## Ends in an error in state: 384.
##
## module_path(field_path) -> UIdent DOT . module_path(field_path) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(field_path) -> UIdent DOT . field_path [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a value in a module.
At this point, one of the following is expected:
  * a sub-module name;
  * a record name;
  * a tuple name.

interactive_expr: Begin Remove UIdent While
##
## Ends in an error in state: 391.
##
## remove(BigMap,expr) -> Remove expr . From BigMap expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Map,expr) -> Remove expr . From Map expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Set,expr) -> Remove expr . From Set expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##
interactive_expr: Begin If UIdent Then Remove UIdent While
##
## Ends in an error in state: 476.
##
## remove(BigMap,closed_expr) -> Remove expr . From BigMap closed_expr [ Else ]
## remove(BigMap,expr) -> Remove expr . From BigMap expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Map,closed_expr) -> Remove expr . From Map closed_expr [ Else ]
## remove(Map,expr) -> Remove expr . From Map expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove(Set,closed_expr) -> Remove expr . From Set closed_expr [ Else ]
## remove(Set,expr) -> Remove expr . From Set expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed removal from a collection.
At this point, if the item to remove is complete, the keyword `from`
is expected, followed either the keyword 'big_map', 'map' or 'set'.

interactive_expr: Begin Remove UIdent From BigMap With
##
## Ends in an error in state: 397.
##
## remove(BigMap,expr) -> Remove expr From BigMap . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From BigMap
##
interactive_expr: Begin If UIdent Then Remove UIdent From BigMap With
##
## Ends in an error in state: 508.
##
## remove(BigMap,closed_expr) -> Remove expr From BigMap . closed_expr [ Else ]
## remove(BigMap,expr) -> Remove expr From BigMap . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From BigMap
##

Ill-formed removal from a big map.
At this point, the big map is expected as an expression.

contract: Module UIdent Is Block With
##
## Ends in an error in state: 463.
##
## terse_module_decl -> Module UIdent Is option(Block) . LBRACE declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is option(Block)
##

Ill-formed module declaration.
At this point, an opening brace '{' is expected, followed by
declarations.

interactive_expr: Begin LPAR With
##
## Ends in an error in state: 468.
##
## par(expr) -> LPAR . expr RPAR [ LBRACKET DOT ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised expression.
At this point, an expression is expected, followed by a closing
parenthesis ')'.

interactive_expr: Begin LPAR UIdent While
##
## Ends in an error in state: 469.
##
## par(expr) -> LPAR expr . RPAR [ LBRACKET DOT ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed parenthesised expression.
At this point, if the expression is complete, a closing parenthesis
')' is expected.

interactive_expr: Begin If UIdent While
##
## Ends in an error in state: 472.
##
## if_then_else_instr(instruction) -> If expr . Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If expr . Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##
interactive_expr: Begin If UIdent Then If UIdent While
##
## Ends in an error in state: 511.
##
## if_then_else_instr(closed_instr) -> If expr . Then test_clause(closed_instr) Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr . Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr(instruction) -> If expr . Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed conditional instruction.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an instruction or a block of statements
(instructions and declarations).

interactive_expr: If UIdent Then If UIdent While
##
## Ends in an error in state: 480.
##
## if_then_else_expr(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
## if_then_else_expr(expr) -> If expr . Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If expr . Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##
interactive_expr: If UIdent While
##
## Ends in an error in state: 668.
##
## if_then_else_expr(expr) -> If expr . Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr(expr) -> If expr . Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed conditional expression.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an expression.

interactive_expr: If UIdent Then Function With
##
## Ends in an error in state: 482.
##
## fun_expr(closed_expr) -> Function . parameters Is closed_expr [ Else ]
## fun_expr(closed_expr) -> Function . parameters type_annotation Is closed_expr [ Else ]
## fun_expr(expr) -> Function . parameters Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function . parameters type_annotation Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function
##

Ill-formed function expression.
At this point, parameter declarations are expected between parentheses.

interactive_expr: If UIdent Then Function LPAR Const Ident RPAR With
##
## Ends in an error in state: 483.
##
## fun_expr(closed_expr) -> Function parameters . Is closed_expr [ Else ]
## fun_expr(closed_expr) -> Function parameters . type_annotation Is closed_expr [ Else ]
## fun_expr(expr) -> Function parameters . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function parameters . type_annotation Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters
##

Ill-formed function declaration.
At this point, one of the following is expected:
  * the keyword 'is' followed by the body as an expression;
  * a type annotation starting with a colon ':' for the return value.

interactive_expr: If UIdent Then Function LPAR Const Ident RPAR COLON UIdent ARROW
##
## Ends in an error in state: 496.
##
## fun_expr(closed_expr) -> Function parameters type_annotation . Is closed_expr [ Else ]
## fun_expr(expr) -> Function parameters type_annotation . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters type_annotation
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 24, spurious reduction of production variant -> UIdent
## In state 43, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 62, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 55, spurious reduction of production type_expr -> sum_type
## In state 80, spurious reduction of production type_annotation -> COLON type_expr
##

Ill-formed function declaration.
At this point, if the return type is complete, the keyword 'is' is
expected, followed by the body as an expression.

interactive_expr: If UIdent Then LBRACE Skip RBRACE While
##
## Ends in an error in state: 492.
##
## block_with(closed_expr) -> block . With closed_expr [ Else ]
## block_with(expr) -> block . With expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block
##

Ill-formed block expression.
At this point, the keyword 'with' is expected, followed by an
expression (whose value is that of the block).

interactive_expr: If UIdent Then LBRACE Skip RBRACE With With
##
## Ends in an error in state: 493.
##
## block_with(closed_expr) -> block With . closed_expr [ Else ]
## block_with(expr) -> block With . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block With
##

Ill-formed block expression.
At this point, an expression is expected, whose value is that of the
block.

interactive_expr: Begin For Ident In List UIdent While
##
## Ends in an error in state: 519.
##
## for_in -> For Ident In collection expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In collection expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin For Ident ASS UIdent While
##
## Ends in an error in state: 522.
##
## for_int -> For Ident ASS expr . To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS expr . To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin For Ident ASS UIdent To UIdent While
##
## Ends in an error in state: 524.
##
## for_int -> For Ident ASS expr To expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS expr To expr . step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin For Ident ARROW Ident In Map UIdent While
##
## Ends in an error in state: 534.
##
## for_in -> For Ident ARROW Ident In Map expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident In Map expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Case UIdent While
##
## Ends in an error in state: 537.
##
## terse_case(test_clause(instruction)) -> Case expr . Of LBRACKET option(VBAR) cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## verb_case(test_clause(instruction)) -> Case expr . Of option(VBAR) cases(test_clause(instruction)) End [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin LPAR UIdent RPAR With
##
## Ends in an error in state: 561.
##
## local_path -> par(expr) . DOT nsepseq(selection,DOT) [ LPAR LBRACKET ASS ]
## map_lookup -> par(expr) . brackets(expr) [ ASS ]
##
## The known suffix of the stack is as follows:
## par(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If UIdent Then If UIdent Then Skip With
##
## Ends in an error in state: 592.
##
## if_then_else_instr(closed_instr) -> If expr Then test_clause(closed_instr) . Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) . Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 474, spurious reduction of production base_instr(closed_instr,closed_expr) -> Skip
## In state 615, spurious reduction of production closed_instr -> base_instr(closed_instr,closed_expr)
## In state 610, spurious reduction of production test_clause(closed_instr) -> closed_instr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If UIdent Then Ident With
##
## Ends in an error in state: 604.
##
## assignment(closed_expr) -> lhs . ASS closed_expr [ Else ]
## assignment(expr) -> lhs . ASS expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 145, spurious reduction of production field_path -> Ident
## In state 293, spurious reduction of production local_path -> field_path
## In state 286, spurious reduction of production path_expr -> local_path
## In state 554, spurious reduction of production lhs -> path_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If UIdent Then Ident ASS With
##
## Ends in an error in state: 605.
##
## assignment(closed_expr) -> lhs ASS . closed_expr [ Else ]
## assignment(expr) -> lhs ASS . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## lhs ASS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident LBRACKET UIdent While
##
## Ends in an error in state: 630.
##
## brackets(expr) -> LBRACKET expr . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin While UIdent While
##
## Ends in an error in state: 632.
##
## while_loop -> While expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## While expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: BigMap LBRACKET UIdent ARROW UIdent While
##
## Ends in an error in state: 636.
##
## terse_inj(BigMap,binding) -> BigMap LBRACKET sep_or_term_list(binding,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap LBRACKET sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 642, spurious reduction of production binding -> expr ARROW expr
## In state 643, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 639, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: BigMap UIdent While
##
## Ends in an error in state: 640.
##
## binding -> expr . ARROW expr [ SEMI RBRACKET End ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: BigMap UIdent ARROW UIdent While
##
## Ends in an error in state: 648.
##
## verb_inj(BigMap,binding) -> BigMap sep_or_term_list(binding,SEMI) . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 642, spurious reduction of production binding -> expr ARROW expr
## In state 643, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 639, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Case UIdent While
##
## Ends in an error in state: 650.
##
## terse_case(expr) -> Case expr . Of LBRACKET option(VBAR) cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## verb_case(expr) -> Case expr . Of option(VBAR) cases(expr) End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Case UIdent Of LBRACKET UIdent ARROW UIdent While
##
## Ends in an error in state: 658.
##
## terse_case(expr) -> Case expr Of LBRACKET option(VBAR) cases(expr) . RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET option(VBAR) cases(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 656, spurious reduction of production case_clause(expr) -> pattern ARROW expr
## In state 660, spurious reduction of production nsepseq(case_clause(expr),VBAR) -> case_clause(expr)
## In state 657, spurious reduction of production cases(expr) -> nsepseq(case_clause(expr),VBAR)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Case UIdent Of UIdent ARROW UIdent While
##
## Ends in an error in state: 664.
##
## verb_case(expr) -> Case expr Of option(VBAR) cases(expr) . End [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of option(VBAR) cases(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 656, spurious reduction of production case_clause(expr) -> pattern ARROW expr
## In state 660, spurious reduction of production nsepseq(case_clause(expr),VBAR) -> case_clause(expr)
## In state 657, spurious reduction of production cases(expr) -> nsepseq(case_clause(expr),VBAR)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LPAR UIdent COMMA UIdent While
##
## Ends in an error in state: 674.
##
## par(tuple(expr)) -> LPAR tuple(expr) . RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR tuple(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 679, spurious reduction of production nsepseq(expr,COMMA) -> expr
## In state 678, spurious reduction of production tuple(expr) -> expr COMMA nsepseq(expr,COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LPAR UIdent While
##
## Ends in an error in state: 676.
##
## par(expr) -> LPAR expr . RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive DOT Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## tuple(expr) -> expr . COMMA nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 682, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Lang UIdent While
##
## Ends in an error in state: 684.
##
## code_inj -> Lang expr . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Lang expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: List LBRACKET UIdent While
##
## Ends in an error in state: 688.
##
## terse_inj(List,expr) -> List LBRACKET sep_or_term_list(expr,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 692, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 691, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: List UIdent While
##
## Ends in an error in state: 697.
##
## verb_inj(List,expr) -> List sep_or_term_list(expr,SEMI) . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## List sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 692, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 691, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Map LBRACKET UIdent ARROW UIdent While
##
## Ends in an error in state: 702.
##
## terse_inj(Map,binding) -> Map LBRACKET sep_or_term_list(binding,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Map LBRACKET sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 642, spurious reduction of production binding -> expr ARROW expr
## In state 643, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 639, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Record LBRACKET Ident While
##
## Ends in an error in state: 709.
##
## terse_inj(Record,field_assignment) -> Record LBRACKET sep_or_term_list(field_assignment,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 132, spurious reduction of production field_assignment -> Ident
## In state 713, spurious reduction of production nsepseq(field_assignment,SEMI) -> field_assignment
## In state 712, spurious reduction of production sep_or_term_list(field_assignment,SEMI) -> nsepseq(field_assignment,SEMI)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Set LBRACKET UIdent While
##
## Ends in an error in state: 722.
##
## terse_inj(Set,expr) -> Set LBRACKET sep_or_term_list(expr,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Set LBRACKET sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 692, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 691, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Set UIdent While
##
## Ends in an error in state: 725.
##
## verb_inj(Set,expr) -> Set sep_or_term_list(expr,SEMI) . End [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Set sep_or_term_list(expr,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 692, spurious reduction of production nsepseq(expr,SEMI) -> expr
## In state 691, spurious reduction of production sep_or_term_list(expr,SEMI) -> nsepseq(expr,SEMI)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident LPAR UIdent While
##
## Ends in an error in state: 727.
##
## par(nsepseq(expr,COMMA)) -> LPAR nsepseq(expr,COMMA) . RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(expr,COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 125, spurious reduction of production ctor_app(arguments) -> UIdent
## In state 295, spurious reduction of production ctor_expr -> ctor_app(arguments)
## In state 294, spurious reduction of production core_expr -> ctor_expr
## In state 296, spurious reduction of production update_expr_level -> core_expr
## In state 172, spurious reduction of production unary_expr_level -> update_expr_level
## In state 176, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 279, spurious reduction of production add_expr_level -> mult_expr_level
## In state 330, spurious reduction of production cons_expr_level -> add_expr_level
## In state 317, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 357, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 344, spurious reduction of production set_mem_level -> comp_expr_level
## In state 191, spurious reduction of production conj_expr_level -> set_mem_level
## In state 364, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 315, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 370, spurious reduction of production expr -> base_expr(expr)
## In state 679, spurious reduction of production nsepseq(expr,COMMA) -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>
