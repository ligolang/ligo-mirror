(* Token specification for CameLIGO *)

(* Vendor dependencies *)

module Region    = Simple_utils.Region
module Markup    = LexerLib.Markup
module Directive = LexerLib.Directive

(* Utility modules and types *)

module SMap = Map.Make (String)
module Wrap = Lexing_shared.Wrap
module Attr = Lexing_shared.Attr

let sprintf = Printf.sprintf

let wrap = Wrap.wrap

module T =
  struct
    (* A lexeme is the concrete syntax of a token *)

    type lexeme = string

    (* Definition of tokens generated by "menhir --only-tokens"

       It contains [token] and ['a terminal] types. The first one we
       redefine manually here (by type [t]) but the second one we need
       to satisfy Menhir's Inspection API.  *)

    include Menhir_cameligo_tokens.MenhirToken

    (* TOKENS *)

    type t =
      (* Preprocessing directives *)

      Directive of Directive.t

      (* Literals *)

    | String   of lexeme Wrap.t
    | Verbatim of lexeme Wrap.t
    | Bytes    of (lexeme * Hex.t) Wrap.t
    | Int      of (lexeme * Z.t) Wrap.t
    | Nat      of (lexeme * Z.t) Wrap.t
    | Mutez    of (lexeme * Int64.t) Wrap.t
    | Ident    of lexeme Wrap.t
    | UIdent   of lexeme Wrap.t
    | Lang     of lexeme Region.reg Region.reg
    | Attr     of Attr.t Region.reg

    (* Symbols *)

    | ARROW    of lexeme Wrap.t  (* -> *)
    | CONS     of lexeme Wrap.t  (* :: *)
    | CARET    of lexeme Wrap.t  (* ^  *)
    | MINUS    of lexeme Wrap.t  (* -  *)
    | PLUS     of lexeme Wrap.t  (* +  *)
    | SLASH    of lexeme Wrap.t  (* /  *)
    | TIMES    of lexeme Wrap.t  (* *  *)
    | LPAR     of lexeme Wrap.t  (* (  *)
    | RPAR     of lexeme Wrap.t  (* )  *)
    | LBRACKET of lexeme Wrap.t  (* [  *)
    | RBRACKET of lexeme Wrap.t  (* ]  *)
    | LBRACE   of lexeme Wrap.t  (* {  *)
    | RBRACE   of lexeme Wrap.t  (* }  *)
    | COMMA    of lexeme Wrap.t  (* ,  *)
    | SEMI     of lexeme Wrap.t  (* ;  *)
    | VBAR     of lexeme Wrap.t  (* |  *)
    | COLON    of lexeme Wrap.t  (* :  *)
    | DOT      of lexeme Wrap.t  (* .  *)
    | WILD     of lexeme Wrap.t  (* _  *)
    | EQ       of lexeme Wrap.t  (* =  *)
    | NE       of lexeme Wrap.t  (* <> *)
    | LT       of lexeme Wrap.t  (* <  *)
    | GT       of lexeme Wrap.t  (* >  *)
    | LE       of lexeme Wrap.t  (* <= *)
    | GE       of lexeme Wrap.t  (* >= *)
    | BOOL_OR  of lexeme Wrap.t  (* || *)
    | BOOL_AND of lexeme Wrap.t  (* && *)
    | QUOTE    of lexeme Wrap.t  (* '  *)

    (* Keywords *)

    | Begin     of lexeme Wrap.t  (* begin  *)
    | Else      of lexeme Wrap.t  (* else   *)
    | End       of lexeme Wrap.t  (* end    *)
    | Fun       of lexeme Wrap.t  (* fun    *)
    | Rec       of lexeme Wrap.t  (* rec    *)
    | If        of lexeme Wrap.t  (* if     *)
    | In        of lexeme Wrap.t  (* in     *)
    | Let       of lexeme Wrap.t  (* let    *)
    | Match     of lexeme Wrap.t  (* match  *)
    | Mod       of lexeme Wrap.t  (* mod    *)
    | Land      of lexeme Wrap.t  (* land   *)
    | Lor       of lexeme Wrap.t  (* lor    *)
    | Lxor      of lexeme Wrap.t  (* lxor   *)
    | Lsl       of lexeme Wrap.t  (* lsl    *)
    | Lsr       of lexeme Wrap.t  (* lsr    *)
    | Not       of lexeme Wrap.t  (* not    *)
    | Of        of lexeme Wrap.t  (* of     *)
    | Or        of lexeme Wrap.t  (* or     *)
    | Then      of lexeme Wrap.t  (* then   *)
    | Type      of lexeme Wrap.t  (* type   *)
    | With      of lexeme Wrap.t  (* with   *)
    | Module    of lexeme Wrap.t  (* module *)
    | Struct    of lexeme Wrap.t  (* struct *)

    (* End-Of-File *)

    | EOF of lexeme Wrap.t

    type token = t


    (* FROM TOKENS TO LEXEMES *)

    let to_lexeme = function
      (* Directives *)

      Directive d -> Directive.to_lexeme d

      (* Literals *)

    | String t   -> sprintf "%S" t#payload (* Escaped *)
    | Verbatim t -> String.escaped t#payload
    | Bytes t    -> fst t#payload
    | Int t
    | Nat t      -> fst t#payload
    | Mutez t    -> fst t#payload
    | Ident t
    | UIdent t   -> t#payload
    | Attr t     -> Attr.to_lexeme t.Region.value
    | Lang lang  -> Region.(lang.value.value)

    (* Symbols *)

    | ARROW    t
    | CONS     t
    | CARET    t
    | MINUS    t
    | PLUS     t
    | SLASH    t
    | TIMES    t
    | LPAR     t
    | RPAR     t
    | LBRACKET t
    | RBRACKET t
    | LBRACE   t
    | RBRACE   t
    | COMMA    t
    | SEMI     t
    | VBAR     t
    | COLON    t
    | DOT      t
    | WILD     t
    | EQ       t
    | NE       t
    | LT       t
    | GT       t
    | LE       t
    | GE       t
    | BOOL_OR  t
    | BOOL_AND t
    | QUOTE    t

    (* Keywords *)

    | Begin  t
    | Else   t
    | End    t
    | Fun    t
    | Rec    t
    | If     t
    | In     t
    | Let    t
    | Match  t
    | Mod    t
    | Land   t
    | Lor    t
    | Lxor   t
    | Lsl    t
    | Lsr    t
    | Not    t
    | Of     t
    | Or     t
    | Type   t
    | Then   t
    | With   t
    | Module t
    | Struct t -> t#payload

    (* End-Of-File *)

    | EOF _ -> ""


    (* KEYWORDS *)

    let mk_Begin  region = Begin  (wrap "begin"  region)
    let mk_Else   region = Else   (wrap "else"   region)
    let mk_End    region = End    (wrap "end"    region)
    let mk_Fun    region = Fun    (wrap "fun"    region)
    let mk_Rec    region = Rec    (wrap "rec"    region)
    let mk_If     region = If     (wrap "if"     region)
    let mk_In     region = In     (wrap "in"     region)
    let mk_Let    region = Let    (wrap "let"    region)
    let mk_Match  region = Match  (wrap "match"  region)
    let mk_Mod    region = Mod    (wrap "mod"    region)
    let mk_Land   region = Land   (wrap "land"   region)
    let mk_Lor    region = Lor    (wrap "lor"    region)
    let mk_Lxor   region = Lxor   (wrap "lxor"   region)
    let mk_Lsl    region = Lsl    (wrap "lsl"    region)
    let mk_Lsr    region = Lsr    (wrap "lsr"    region)
    let mk_Not    region = Not    (wrap "not"    region)
    let mk_Of     region = Of     (wrap "of"     region)
    let mk_Or     region = Or     (wrap "or"     region)
    let mk_Then   region = Then   (wrap "then"   region)
    let mk_Type   region = Type   (wrap "type"   region)
    let mk_With   region = With   (wrap "with"   region)
    let mk_Module region = Module (wrap "module" region)
    let mk_Struct region = Struct (wrap "struct" region)

    let keywords = [
      mk_Begin;
      mk_Else;
      mk_End;
      mk_Fun;
      mk_Rec;
      mk_If;
      mk_In;
      mk_Let;
      mk_Match;
      mk_Mod;
      mk_Land;
      mk_Lor;
      mk_Lxor;
      mk_Lsl;
      mk_Lsr;
      mk_Not;
      mk_Of;
      mk_Or;
      mk_Then;
      mk_Type;
      mk_With;
      mk_Module;
      mk_Struct
    ]

    let keywords =
      let add map (key, value) = SMap.add key value map in
      let apply map mk_kwd =
        add map (to_lexeme (mk_kwd Region.ghost), mk_kwd)
      in List.fold_left apply SMap.empty keywords

    (* SYMBOLS *)

    let mk_ARROW    region = ARROW    (wrap "->" region)
    let mk_CONS     region = CONS     (wrap "::" region)
    let mk_CARET    region = CARET    (wrap "^"  region)
    let mk_MINUS    region = MINUS    (wrap "-"  region)
    let mk_PLUS     region = PLUS     (wrap "+"  region)
    let mk_SLASH    region = SLASH    (wrap "/"  region)
    let mk_TIMES    region = TIMES    (wrap "*"  region)
    let mk_LPAR     region = LPAR     (wrap "("  region)
    let mk_RPAR     region = RPAR     (wrap ")"  region)
    let mk_LBRACKET region = LBRACKET (wrap "["  region)
    let mk_RBRACKET region = RBRACKET (wrap "]"  region)
    let mk_LBRACE   region = LBRACE   (wrap "{"  region)
    let mk_RBRACE   region = RBRACE   (wrap "}"  region)
    let mk_COMMA    region = COMMA    (wrap ","  region)
    let mk_SEMI     region = SEMI     (wrap ";"  region)
    let mk_VBAR     region = VBAR     (wrap "|"  region)
    let mk_COLON    region = COLON    (wrap ":"  region)
    let mk_DOT      region = DOT      (wrap "."  region)
    let mk_WILD     region = WILD     (wrap "_"  region)
    let mk_EQ       region = EQ       (wrap "="  region)
    let mk_NE       region = NE       (wrap "<>" region)
    let mk_LT       region = LT       (wrap "<"  region)
    let mk_GT       region = GT       (wrap ">"  region)
    let mk_LE       region = LE       (wrap "<=" region)
    let mk_GE       region = GE       (wrap ">=" region)
    let mk_BOOL_OR  region = BOOL_OR  (wrap "||" region)
    let mk_BOOL_AND region = BOOL_AND (wrap "&&" region)
    let mk_QUOTE    region = QUOTE    (wrap "'"  region)

    let symbols = [
      mk_ARROW;
      mk_CONS;
      mk_CARET;
      mk_MINUS;
      mk_PLUS;
      mk_SLASH;
      mk_TIMES;
      mk_LPAR;
      mk_RPAR;
      mk_LBRACKET;
      mk_RBRACKET;
      mk_LBRACE;
      mk_RBRACE;
      mk_COMMA;
      mk_SEMI;
      mk_VBAR;
      mk_COLON;
      mk_DOT;
      mk_WILD;
      mk_EQ;
      mk_NE;
      mk_LT;
      mk_GT;
      mk_LE;
      mk_GE;
      mk_BOOL_OR;
      mk_BOOL_AND;
      mk_QUOTE
    ]

    let symbols =
      let add map (key, value) = SMap.add key value map in
      let apply map mk_kwd =
        add map (to_lexeme (mk_kwd Region.ghost), mk_kwd)
      in List.fold_left apply SMap.empty symbols


    (* GHOST TOKEN ARGUMENTS *)

    (* IMPORTANT: These values cannot be exported in Token.mli *)

    let ghost_String   = Wrap.ghost "\"a string\""
    let ghost_Verbatim = Wrap.ghost "{|verbatim|}"
    let ghost_Bytes    = Wrap.ghost ("0xAA", `Hex "AA")
    let ghost_Int      = Wrap.ghost ("1", Z.one)
    let ghost_Nat      = Wrap.ghost ("1n", Z.one)
    let ghost_Mutez    = Wrap.ghost ("1mutez", Int64.one)
    let ghost_Ident    = Wrap.ghost "id"
    let ghost_UIdent   = Wrap.ghost "C"
    let ghost_Lang     = Region.(wrap_ghost "Michelson")
    let ghost_Attr     = Region.(wrap_ghost (wrap_ghost ("attr", None)))

    let ghost_ARROW    = mk_ARROW    Region.ghost
    let ghost_CONS     = mk_CONS     Region.ghost
    let ghost_CARET    = mk_CARET    Region.ghost
    let ghost_MINUS    = mk_MINUS    Region.ghost
    let ghost_PLUS     = mk_PLUS     Region.ghost
    let ghost_SLASH    = mk_SLASH    Region.ghost
    let ghost_TIMES    = mk_TIMES    Region.ghost
    let ghost_LPAR     = mk_LPAR     Region.ghost
    let ghost_RPAR     = mk_RPAR     Region.ghost
    let ghost_LBRACKET = mk_LBRACKET Region.ghost
    let ghost_RBRACKET = mk_RBRACKET Region.ghost
    let ghost_LBRACE   = mk_LBRACE   Region.ghost
    let ghost_RBRACE   = mk_RBRACE   Region.ghost
    let ghost_COMMA    = mk_COMMA    Region.ghost
    let ghost_SEMI     = mk_SEMI     Region.ghost
    let ghost_VBAR     = mk_VBAR     Region.ghost
    let ghost_COLON    = mk_COLON    Region.ghost
    let ghost_DOT      = mk_DOT      Region.ghost
    let ghost_WILD     = mk_WILD     Region.ghost
    let ghost_EQ       = mk_EQ       Region.ghost
    let ghost_NE       = mk_NE       Region.ghost
    let ghost_LT       = mk_LT       Region.ghost
    let ghost_GT       = mk_GT       Region.ghost
    let ghost_LE       = mk_LE       Region.ghost
    let ghost_GE       = mk_GE       Region.ghost
    let ghost_BOOL_OR  = mk_BOOL_OR  Region.ghost
    let ghost_BOOL_AND = mk_BOOL_AND Region.ghost
    let ghost_QUOTE    = mk_QUOTE    Region.ghost

    let ghost_Begin    = mk_Begin    Region.ghost
    let ghost_Else     = mk_Else     Region.ghost
    let ghost_End      = mk_End      Region.ghost
    let ghost_Fun      = mk_Fun      Region.ghost
    let ghost_Rec      = mk_Rec      Region.ghost
    let ghost_If       = mk_If       Region.ghost
    let ghost_In       = mk_In       Region.ghost
    let ghost_Let      = mk_Let      Region.ghost
    let ghost_Match    = mk_Match    Region.ghost
    let ghost_Mod      = mk_Mod      Region.ghost
    let ghost_Land     = mk_Land     Region.ghost
    let ghost_Lor      = mk_Lor      Region.ghost
    let ghost_Lxor     = mk_Lxor     Region.ghost
    let ghost_Lsl      = mk_Lsl      Region.ghost
    let ghost_Lsr      = mk_Lsr      Region.ghost
    let ghost_Not      = mk_Not      Region.ghost
    let ghost_Of       = mk_Of       Region.ghost
    let ghost_Or       = mk_Or       Region.ghost
    let ghost_Then     = mk_Then     Region.ghost
    let ghost_Type     = mk_Type     Region.ghost
    let ghost_With     = mk_With     Region.ghost
    let ghost_Module   = mk_Module   Region.ghost
    let ghost_Struct   = mk_Struct   Region.ghost

    let ghost_EOF      = Wrap.ghost ""


    (* FROM TOKEN STRINGS TO LEXEMES *)

    (* TODO: Remove. We don't need fresh variables for syntax checking.

`   let gen_sym prefix =
      let count = ref 0 in
      fun () -> incr count; prefix ^ string_of_int !count

    let id_sym   = gen_sym "id"
    and ctor_sym = gen_sym "C"
     *)

    let concrete = function
      "Ident"    -> ghost_Ident#payload (*id_sym ()*)
    | "UIdent"   -> ghost_UIdent#payload (*ctor_sym ()*)
    | "Int"      -> fst ghost_Int#payload
    | "Nat"      -> fst ghost_Nat#payload
    | "Mutez"    -> fst ghost_Mutez#payload
    | "String"   -> ghost_String#payload
    | "Verbatim" -> ghost_Verbatim#payload
    | "Bytes"    -> fst ghost_Bytes#payload
    | "Attr"     -> Attr.to_lexeme Region.(ghost_Attr.value.value)
    | "Lang"     -> "[%" ^ ghost_Lang.Region.value

    (* Symbols *)

    | "ARROW"    -> to_lexeme ghost_ARROW
    | "CONS"     -> to_lexeme ghost_CONS
    | "CARET"    -> to_lexeme ghost_CARET
    | "MINUS"    -> to_lexeme ghost_MINUS
    | "PLUS"     -> to_lexeme ghost_PLUS
    | "SLASH"    -> to_lexeme ghost_SLASH
    | "TIMES"    -> to_lexeme ghost_TIMES
    | "LPAR"     -> to_lexeme ghost_LPAR
    | "RPAR"     -> to_lexeme ghost_RPAR
    | "LBRACE"   -> to_lexeme ghost_LBRACE
    | "RBRACE"   -> to_lexeme ghost_RBRACE
    | "LBRACKET" -> to_lexeme ghost_LBRACKET
    | "RBRACKET" -> to_lexeme ghost_RBRACKET
    | "COMMA"    -> to_lexeme ghost_COMMA
    | "SEMI"     -> to_lexeme ghost_SEMI
    | "VBAR"     -> to_lexeme ghost_VBAR
    | "COLON"    -> to_lexeme ghost_COLON
    | "DOT"      -> to_lexeme ghost_DOT
    | "WILD"     -> to_lexeme ghost_WILD
    | "EQ"       -> to_lexeme ghost_EQ
    | "NE"       -> to_lexeme ghost_NE
    | "LT"       -> to_lexeme ghost_LT
    | "GT"       -> to_lexeme ghost_GT
    | "LE"       -> to_lexeme ghost_LE
    | "GE"       -> to_lexeme ghost_GE
    | "BOOL_OR"  -> to_lexeme ghost_BOOL_OR
    | "BOOL_AND" -> to_lexeme ghost_BOOL_AND
    | "QUOTE"    -> to_lexeme ghost_QUOTE

    (* Keywords *)

    | "Begin"  -> to_lexeme ghost_Begin
    | "Else"   -> to_lexeme ghost_Else
    | "End"    -> to_lexeme ghost_End
    | "Fun"    -> to_lexeme ghost_Fun
    | "Rec"    -> to_lexeme ghost_Rec
    | "If"     -> to_lexeme ghost_If
    | "In"     -> to_lexeme ghost_In
    | "Let"    -> to_lexeme ghost_Let
    | "Match"  -> to_lexeme ghost_Match
    | "Mod"    -> to_lexeme ghost_Mod
    | "Land"   -> to_lexeme ghost_Land
    | "Lor"    -> to_lexeme ghost_Lor
    | "Lxor"   -> to_lexeme ghost_Lxor
    | "Lsl"    -> to_lexeme ghost_Lsl
    | "Lsr"    -> to_lexeme ghost_Lsr
    | "Not"    -> to_lexeme ghost_Not
    | "Of"     -> to_lexeme ghost_Of
    | "Or"     -> to_lexeme ghost_Or
    | "Then"   -> to_lexeme ghost_Then
    | "Type"   -> to_lexeme ghost_Type
    | "With"   -> to_lexeme ghost_With
    | "Module" -> to_lexeme ghost_Module
    | "Struct" -> to_lexeme ghost_Struct

    (* End-Of-File *)

    | "EOF" -> ghost_EOF#payload

    (* This case should not happen! *)

    | _  -> "\\Unknown" (* Backslash meant to trigger an error *)


    (* FROM TOKENS TO TOKEN STRINGS AND REGIONS *)

    let proj_token = function
      (* Preprocessing directives *)

      Directive d -> Directive.project d

      (* Literals *)

    | String t ->
        t#region, sprintf "String %S" t#payload
    | Verbatim t ->
        t#region, sprintf "Verbatim %S" t#payload
    | Bytes t ->
        let s, b = t#payload in
        t#region,
        sprintf "Bytes (%S, \"0x%s\")" s (Hex.show b)
    | Int t ->
        let s, n = t#payload in
        t#region, sprintf "Int (%S, %s)" s (Z.to_string n)
    | Nat t ->
        let s, n = t#payload in
        t#region, sprintf "Nat (%S, %s)" s (Z.to_string n)
    | Mutez t ->
        let s, n = t#payload in
        t#region, sprintf "Mutez (%S, %s)" s (Int64.to_string n)
    | Ident t ->
        t#region, sprintf "Ident %S" t#payload
    | UIdent t ->
        t#region, sprintf "UIdent %S" t#payload
    | Attr {region; value} ->
        region, sprintf "Attr %s" (Attr.to_string value)
    | Lang {value = {value = payload; _}; region; _} ->
        region, sprintf "Lang %S" payload

    (* Symbols *)

    | ARROW    t -> t#region, "ARROW"
    | CONS     t -> t#region, "CONS"
    | CARET    t -> t#region, "CARET"
    | MINUS    t -> t#region, "MINUS"
    | PLUS     t -> t#region, "PLUS"
    | SLASH    t -> t#region, "SLASH"
    | TIMES    t -> t#region, "TIMES"
    | LPAR     t -> t#region, "LPAR"
    | RPAR     t -> t#region, "RPAR"
    | LBRACKET t -> t#region, "LBRACKET"
    | RBRACKET t -> t#region, "RBRACKET"
    | LBRACE   t -> t#region, "LBRACE"
    | RBRACE   t -> t#region, "RBRACE"
    | COMMA    t -> t#region, "COMMA"
    | SEMI     t -> t#region, "SEMI"
    | VBAR     t -> t#region, "VBAR"
    | COLON    t -> t#region, "COLON"
    | DOT      t -> t#region, "DOT"
    | WILD     t -> t#region, "WILD"
    | EQ       t -> t#region, "EQ"
    | NE       t -> t#region, "NE"
    | LT       t -> t#region, "LT"
    | GT       t -> t#region, "GT"
    | LE       t -> t#region, "LE"
    | GE       t -> t#region, "GE"
    | BOOL_OR  t -> t#region, "BOOL_OR"
    | BOOL_AND t -> t#region, "BOOL_AND"
    | QUOTE    t -> t#region, "QUOTE"

    (* Keywords *)

    | Begin  t -> t#region, "Begin"
    | Else   t -> t#region, "Else"
    | End    t -> t#region, "End"
    | Fun    t -> t#region, "Fun"
    | Rec    t -> t#region, "Rec"
    | If     t -> t#region, "If"
    | In     t -> t#region, "In"
    | Let    t -> t#region, "Let"
    | Match  t -> t#region, "Match"
    | Mod    t -> t#region, "Mod"
    | Land   t -> t#region, "Land"
    | Lor    t -> t#region, "Lor"
    | Lxor   t -> t#region, "Lxor"
    | Lsl    t -> t#region, "Lsl"
    | Lsr    t -> t#region, "Lsr"
    | Not    t -> t#region, "Not"
    | Of     t -> t#region, "Of"
    | Or     t -> t#region, "Or"
    | Then   t -> t#region, "Then"
    | Type   t -> t#region, "Type"
    | With   t -> t#region, "With"
    | Module t -> t#region, "Module"
    | Struct t -> t#region, "Struct"

    (* End-Of-File *)

    | EOF t -> t#region, "EOF"


    (* CONVERSIONS *)

    let to_string ~offsets mode token =
      let region, val_str = proj_token token in
      let reg_str = region#compact ~offsets mode
      in sprintf "%s: %s" reg_str val_str

    let to_region token = proj_token token |> fst


    (* SMART CONSTRUCTORS *)

    (* Keywords *)

    type kwd_err = Invalid_keyword

    let mk_kwd ident region =
      match SMap.find_opt ident keywords with
        Some mk_kwd -> Ok (mk_kwd region)
      |        None -> Error Invalid_keyword

    (* Directives *)

    let mk_directive dir = Directive dir

    (* Strings *)

    let mk_string lexeme region = String (wrap lexeme region)

    (* Verbatim strings *)

    let mk_verbatim lexeme region = Verbatim (wrap lexeme region)

    (* Bytes *)

    let mk_bytes lexeme bytes region =
      Bytes (wrap (lexeme, `Hex bytes) region)

    (* Integers *)

    let mk_int lexeme z region = Int (wrap (lexeme, z) region)

    (* Natural numbers *)

    type nat_err = Wrong_nat_syntax of string (* Not CameLIGO *)

    let mk_nat nat z region = Ok (Nat (wrap (nat ^ "n", z) region))

    (* Mutez *)

    type mutez_err = Wrong_mutez_syntax of string (* Not CameLIGO *)

    let mk_mutez nat ~suffix int64 region =
      Ok (Mutez (wrap (nat ^ suffix, int64) region))

    (* End-Of-File *)

    let mk_eof region = EOF (wrap "" region)

    (* Symbols *)

    type sym_err = Invalid_symbol of string

    let mk_sym lexeme region =
      match SMap.find_opt lexeme symbols with
        Some mk_sym -> Ok (mk_sym region)
      |        None -> Error (Invalid_symbol lexeme)

    (* Identifiers *)

    let mk_ident value region =
      match SMap.find_opt value keywords with
        Some mk_kwd -> mk_kwd region
      |        None -> Ident (wrap value region)

    (* Constructors/Modules *)

    let mk_uident value region = UIdent (wrap value region)

    (* Attributes *)

    let mk_attr ~key ?value region = Attr {region; value = key, value}

    (* Code injection *)

    type lang_err = Wrong_lang_syntax of string (* Not CameLIGO *)

    let mk_lang lang region = Ok (Lang Region.{value=lang; region})

    (* PREDICATES *)

    let is_int    = function Int    _ -> true | _ -> false
    let is_string = function String _ -> true | _ -> false
    let is_bytes  = function Bytes  _ -> true | _ -> false
    let is_eof    = function EOF    _ -> true | _ -> false

    let hex_digits = ["A"; "B"; "C"; "D"; "E"; "F";
                      "a"; "b"; "c"; "d"; "e"; "f"]

    let is_hex = function
      UIdent t | Ident t -> List.mem t#payload hex_digits
    | _ -> false

    let is_sym = function
      ARROW _
    | CONS _
    | CARET _
    | MINUS _
    | PLUS _
    | SLASH _
    | TIMES _
    | LPAR _
    | RPAR _
    | LBRACKET _
    | RBRACKET _
    | LBRACE _
    | RBRACE _
    | COMMA _
    | SEMI _
    | VBAR _
    | COLON _
    | DOT _
    | WILD _
    | EQ _
    | NE _
    | LT _
    | GT _
    | LE _
    | GE _
    | BOOL_OR _
    | BOOL_AND _ -> true
    | _ -> false

    (* String delimiters *)

    let support_string_delimiter c = (c = '"')

    (* Verbatim strings *)

    let verbatim_delimiters = ("{|", "|}")
  end

include T

module type S = module type of T
