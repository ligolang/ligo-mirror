(* Token specification for PascaLIGO *)

(* Vendor dependencies *)

module Region    = Simple_utils.Region
module Markup    = LexerLib.Markup
module Directive = LexerLib.Directive

(* Utility modules and types *)

module SMap = Map.Make (String)
module Wrap = Lexing_shared.Wrap
module Attr = Lexing_shared.Attr

type 'a wrap = 'a Wrap.t
type 'a reg  = 'a Region.reg

let wrap = Wrap.wrap

(* TOKENS *)

module T =
  struct
    (* A lexeme is the concrete syntax of a token *)

    type lexeme = string

    (* Definition of tokens generated by "menhir --only-tokens"

       It contains [token] and ['a terminal] types. The first one we
       redefine manually here (by type [t]) but the second one we need
       to satisfy Menhir's Inspection API.  *)

    include Menhir_pascaligo_tokens.MenhirToken

    (* Tokens *)

    type t =
      (* Preprocessing directives *)

      Directive of Directive.t

      (* Literals *)

    | String   of lexeme wrap
    | Verbatim of lexeme wrap
    | Bytes    of (lexeme * Hex.t) wrap
    | Int      of (lexeme * Z.t) wrap
    | Nat      of (lexeme * Z.t) wrap
    | Mutez    of (lexeme * Int64.t) wrap
    | Ident    of lexeme wrap
    | UIdent   of lexeme wrap
    | Lang     of lexeme reg reg
    | Attr     of Attr.t reg

    (* Symbols *)

    | SEMI     of lexeme wrap  (* ;   *)
    | COMMA    of lexeme wrap  (* ,   *)
    | LPAR     of lexeme wrap  (* (   *)
    | RPAR     of lexeme wrap  (* )   *)
    | LBRACE   of lexeme wrap  (* {   *)
    | RBRACE   of lexeme wrap  (* }   *)
    | LBRACKET of lexeme wrap  (* [   *)
    | RBRACKET of lexeme wrap  (* ]   *)
    | SHARP    of lexeme wrap  (* #   *)
    | VBAR     of lexeme wrap  (* |   *)
    | ARROW    of lexeme wrap  (* ->  *)
    | ASS      of lexeme wrap  (* :=  *)
    | EQ       of lexeme wrap  (* =   *)
    | COLON    of lexeme wrap  (* :   *)
    | LT       of lexeme wrap  (* <   *)
    | LE       of lexeme wrap  (* <=  *)
    | GT       of lexeme wrap  (* >   *)
    | GE       of lexeme wrap  (* >=  *)
    | NE       of lexeme wrap  (* =/= *)
    | PLUS     of lexeme wrap  (* +   *)
    | MINUS    of lexeme wrap  (* -   *)
    | SLASH    of lexeme wrap  (* /   *)
    | TIMES    of lexeme wrap  (* *   *)
    | DOT      of lexeme wrap  (* .   *)
    | WILD     of lexeme wrap  (* _   *)
    | CARET    of lexeme wrap  (* ^   *)

    (* Keywords *)

    | And        of lexeme wrap  (* and       *)
    | Begin      of lexeme wrap  (* begin     *)
    | BigMap     of lexeme wrap  (* big_map   *)
    | Block      of lexeme wrap  (* block     *)
    | Case       of lexeme wrap  (* case      *)
    | Const      of lexeme wrap  (* const     *)
    | Contains   of lexeme wrap  (* contains  *)
    | Else       of lexeme wrap  (* else      *)
    | End        of lexeme wrap  (* end       *)
    | For        of lexeme wrap  (* for       *)
    | From       of lexeme wrap  (* from      *)
    | Function   of lexeme wrap  (* function  *)
    | Recursive  of lexeme wrap  (* recursive *)
    | If         of lexeme wrap  (* if        *)
    | In         of lexeme wrap  (* in        *)
    | Is         of lexeme wrap  (* is        *)
    | List       of lexeme wrap  (* list      *)
    | Map        of lexeme wrap  (* map       *)
    | Mod        of lexeme wrap  (* mod       *)
    | Nil        of lexeme wrap  (* nil       *)
    | Not        of lexeme wrap  (* not       *)
    | Of         of lexeme wrap  (* of        *)
    | Or         of lexeme wrap  (* or        *)
    | Patch      of lexeme wrap  (* patch     *)
    | Record     of lexeme wrap  (* record    *)
    | Remove     of lexeme wrap  (* remove    *)
    | Set        of lexeme wrap  (* set       *)
    | Skip       of lexeme wrap  (* skip      *)
    | Step       of lexeme wrap  (* step      *)
    | Then       of lexeme wrap  (* then      *)
    | To         of lexeme wrap  (* to        *)
    | Type       of lexeme wrap  (* type      *)
    | Var        of lexeme wrap  (* var       *)
    | While      of lexeme wrap  (* while     *)
    | With       of lexeme wrap  (* with      *)
    | Module     of lexeme wrap  (* module    *)

    (* End-Of-File *)

    | EOF of lexeme wrap

    (* Unlexing the tokens *)

    let gen_sym prefix =
      let count = ref 0 in
      fun () -> incr count; prefix ^ string_of_int !count

    let id_sym   = gen_sym "id"
    and ctor_sym = gen_sym "C"

    let concrete = function
      (* Literals *)

      "Ident"    -> id_sym ()
    | "UIdent"   -> ctor_sym ()
    | "Int"      -> "1"
    | "Nat"      -> "1n"
    | "Mutez"    -> "1mutez"
    | "String"   -> "\"a string\""
    | "Verbatim" -> "{|verbatim|}"
    | "Bytes"    -> "0xAA"
    | "Attr"     -> "[@attr]"
    | "Lang"     -> "[%Michelson"

    (* Symbols *)

    | "SEMI"     -> ";"
    | "COMMA"    -> ","
    | "LPAR"     -> "("
    | "RPAR"     -> ")"
    | "LBRACE"   -> "{"
    | "RBRACE"   -> "}"
    | "LBRACKET" -> "["
    | "RBRACKET" -> "]"
    | "SHARP"    -> "#"
    | "VBAR"     -> "|"
    | "ARROW"    -> "->"
    | "ASS"      -> ":="
    | "EQ"       -> "="
    | "COLON"    -> ":"
    | "LT"       -> "<"
    | "LE"       -> "<="
    | "GT"       -> ">"
    | "GE"       -> ">="
    | "NE"       -> "=/="
    | "PLUS"     -> "+"
    | "MINUS"    -> "-"
    | "SLASH"    -> "/"
    | "TIMES"    -> "*"
    | "DOT"      -> "."
    | "WILD"     -> "_"
    | "CARET"    -> "^"

    (* Keywords *)

    | "And"       -> "and"
    | "Begin"     -> "begin"
    | "BigMap"    -> "big_map"
    | "Block"     ->  "block"
    | "Case"      -> "case"
    | "Const"     -> "const"
    | "Contains"  -> "contains"
    | "Else"      -> "else"
    | "End"       -> "end"
    | "For"       -> "for"
    | "From"      -> "from"
    | "Function"  -> "function"
    | "Recursive" -> "recursive"
    | "If"        -> "if"
    | "In"        -> "in"
    | "Is"        -> "is"
    | "List"      -> "list"
    | "Map"       -> "map"
    | "Mod"       -> "mod"
    | "Nil"       -> "nil"
    | "Not"       -> "not"
    | "Of"        -> "of"
    | "Or"        -> "or"
    | "Patch"     -> "patch"
    | "Record"    -> "record"
    | "Remove"    -> "remove"
    | "Set"       -> "set"
    | "Skip"      -> "skip"
    | "Step"      -> "step"
    | "Then"      -> "then"
    | "To"        -> "to"
    | "Type"      -> "type"
    | "Var"       -> "var"
    | "While"     -> "while"
    | "With"      -> "with"
    | "Module"    -> "module"

    (* End-Of-File *)

    | "EOF" -> ""

    (* This case should not happen! *)

    | _  -> "\\Unknown" (* Backslash meant to trigger an error *)


    (* Projections *)

    let sprintf = Printf.sprintf

    type token = t

    let proj_token = function
      (* Preprocessing directives *)

      Directive d ->
        Directive.project d

      (* Literals *)

    | String t ->
        t#region, sprintf "String %S" t#payload
    | Verbatim t ->
        t#region, sprintf "Verbatim %S" t#payload
    | Bytes t ->
        let s, b = t#payload in
        t#region,
        sprintf "Bytes (%S, \"0x%s\")" s (Hex.show b)
    | Int t ->
        let s, n = t#payload in
        t#region, sprintf "Int (%S, %s)" s (Z.to_string n)
    | Nat t ->
        let s, n = t#payload in
        t#region, sprintf "Nat (%S, %s)" s (Z.to_string n)
    | Mutez t ->
        let s, n = t#payload in
        t#region, sprintf "Mutez (%S, %s)" s (Int64.to_string n)
    | Ident t ->
        t#region, sprintf "Ident %S" t#payload
    | UIdent t ->
        t#region, sprintf "UIdent %S" t#payload
    | Attr {region; value} ->
        region, sprintf "Attr %s" (Attr.to_string value)
    | Lang {value = {value = payload; _}; region; _} ->
        region, sprintf "Lang %S" payload

    (* Symbols *)

    | SEMI     t -> t#region, "SEMI"
    | COMMA    t -> t#region, "COMMA"
    | LPAR     t -> t#region, "LPAR"
    | RPAR     t -> t#region, "RPAR"
    | LBRACE   t -> t#region, "LBRACE"
    | RBRACE   t -> t#region, "RBRACE"
    | LBRACKET t -> t#region, "LBRACKET"
    | RBRACKET t -> t#region, "RBRACKET"
    | SHARP    t -> t#region, "SHARP"
    | VBAR     t -> t#region, "VBAR"
    | ARROW    t -> t#region, "ARROW"
    | ASS      t -> t#region, "ASS"
    | EQ       t -> t#region, "EQ"
    | COLON    t -> t#region, "COLON"
    | LT       t -> t#region, "LT"
    | LE       t -> t#region, "LE"
    | GT       t -> t#region, "GT"
    | GE       t -> t#region, "GE"
    | NE       t -> t#region, "NE"
    | PLUS     t -> t#region, "PLUS"
    | MINUS    t -> t#region, "MINUS"
    | SLASH    t -> t#region, "SLASH"
    | TIMES    t -> t#region, "TIMES"
    | DOT      t -> t#region, "DOT"
    | WILD     t -> t#region, "WILD"
    | CARET    t -> t#region, "CARET"

    (* Keywords *)

    | And       t -> t#region, "And"
    | Begin     t -> t#region, "Begin"
    | BigMap    t -> t#region, "BigMap"
    | Block     t -> t#region, "Block"
    | Case      t -> t#region, "Case"
    | Const     t -> t#region, "Const"
    | Contains  t -> t#region, "Contains"
    | Else      t -> t#region, "Else"
    | End       t -> t#region, "End"
    | For       t -> t#region, "For"
    | From      t -> t#region, "From"
    | Function  t -> t#region, "Function"
    | Recursive t -> t#region, "Recursive"
    | If        t -> t#region, "If"
    | In        t -> t#region, "In"
    | Is        t -> t#region, "Is"
    | List      t -> t#region, "List"
    | Map       t -> t#region, "Map"
    | Mod       t -> t#region, "Mod"
    | Nil       t -> t#region, "Nil"
    | Not       t -> t#region, "Not"
    | Of        t -> t#region, "Of"
    | Or        t -> t#region, "Or"
    | Patch     t -> t#region, "Patch"
    | Record    t -> t#region, "Record"
    | Remove    t -> t#region, "Remove"
    | Set       t -> t#region, "Set"
    | Skip      t -> t#region, "Skip"
    | Step      t -> t#region, "Step"
    | Then      t -> t#region, "Then"
    | To        t -> t#region, "To"
    | Type      t -> t#region, "Type"
    | Var       t -> t#region, "Var"
    | While     t -> t#region, "While"
    | With      t -> t#region, "With"
    | Module    t -> t#region, "Module"

    (* End-Of-File *)

    | EOF t -> t#region, "EOF"


    (* From tokens to lexemes *)

    let to_lexeme = function
      (* Directives *)

      Directive d -> Directive.to_lexeme d

      (* Literals *)

    | String t   -> sprintf "%S" t#payload (* Escaped *)
    | Verbatim t -> String.escaped t#payload
    | Bytes t    -> fst t#payload
    | Int t
    | Nat t      -> fst t#payload
    | Mutez t    -> fst t#payload
    | Ident t
    | UIdent t   -> t#payload
    | Attr t     -> Attr.to_lexeme t.Region.value
    | Lang lang  -> Region.(lang.value.value)

    (* Symbols *)

    | SEMI     t
    | COMMA    t
    | LPAR     t
    | RPAR     t
    | LBRACE   t
    | RBRACE   t
    | LBRACKET t
    | RBRACKET t
    | SHARP    t
    | VBAR     t
    | ARROW    t
    | ASS      t
    | EQ       t
    | COLON    t
    | LT       t
    | LE       t
    | GT       t
    | GE       t
    | NE       t
    | PLUS     t
    | MINUS    t
    | SLASH    t
    | TIMES    t
    | DOT      t
    | WILD     t
    | CARET    t

    (* Keywords *)

    | And       t
    | Begin     t
    | BigMap    t
    | Block     t
    | Case      t
    | Const     t
    | Contains  t
    | Else      t
    | End       t
    | For       t
    | From      t
    | Function  t
    | Recursive t
    | If        t
    | In        t
    | Is        t
    | List      t
    | Map       t
    | Mod       t
    | Nil       t
    | Not       t
    | Of        t
    | Or        t
    | Patch     t
    | Record    t
    | Remove    t
    | Set       t
    | Skip      t
    | Step      t
    | Then      t
    | To        t
    | Type      t
    | Var       t
    | While     t
    | With      t
    | Module    t -> t#payload

    (* End-Of-File *)

    | EOF _ -> ""


    (* CONVERSIONS *)

    let to_string ~offsets mode token =
      let region, val_str = proj_token token in
      let reg_str = region#compact ~offsets mode
      in sprintf "%s: %s" reg_str val_str

    let to_region token = proj_token token |> fst

    (* SMART CONSTRUCTORS *)

    (* Keywords *)

    let keywords = [
      (fun reg -> And       (wrap "and"       reg));
      (fun reg -> Begin     (wrap "begin"     reg));
      (fun reg -> BigMap    (wrap "big_map"   reg));
      (fun reg -> Block     (wrap "block"     reg));
      (fun reg -> Case      (wrap "case"      reg));
      (fun reg -> Const     (wrap "const"     reg));
      (fun reg -> Contains  (wrap "contains"  reg));
      (fun reg -> Else      (wrap "else"      reg));
      (fun reg -> End       (wrap "end"       reg));
      (fun reg -> For       (wrap "for"       reg));
      (fun reg -> From      (wrap "from"      reg));
      (fun reg -> Function  (wrap "function"  reg));
      (fun reg -> If        (wrap "if"        reg));
      (fun reg -> In        (wrap "in"        reg));
      (fun reg -> Is        (wrap "is"        reg));
      (fun reg -> List      (wrap "list"      reg));
      (fun reg -> Map       (wrap "map"       reg));
      (fun reg -> Mod       (wrap "mod"       reg));
      (fun reg -> Nil       (wrap "nil"       reg));
      (fun reg -> Not       (wrap "not"       reg));
      (fun reg -> Of        (wrap "of"        reg));
      (fun reg -> Or        (wrap "or"        reg));
      (fun reg -> Patch     (wrap "patch"     reg));
      (fun reg -> Record    (wrap "record"    reg));
      (fun reg -> Recursive (wrap "recursive" reg));
      (fun reg -> Remove    (wrap "remove"    reg));
      (fun reg -> Set       (wrap "set"       reg));
      (fun reg -> Skip      (wrap "skip"      reg));
      (fun reg -> Step      (wrap "step"      reg));
      (fun reg -> Then      (wrap "then"      reg));
      (fun reg -> To        (wrap "to"        reg));
      (fun reg -> Type      (wrap "type"      reg));
      (fun reg -> Var       (wrap "var"       reg));
      (fun reg -> While     (wrap "while"     reg));
      (fun reg -> With      (wrap "with"      reg));
      (fun reg -> Module    (wrap "module"    reg))
    ]

    let keywords =
      let add map (key, value) = SMap.add key value map in
      let apply map mk_kwd =
        add map (to_lexeme (mk_kwd Region.ghost), mk_kwd)
      in List.fold_left apply SMap.empty keywords

    type kwd_err = Invalid_keyword

    let mk_kwd ident region =
      match SMap.find_opt ident keywords with
        Some mk_kwd -> Ok (mk_kwd region)
      |        None -> Error Invalid_keyword

    (* Directives *)

    let mk_directive dir = Directive dir

    (* Strings *)

    let mk_string lexeme region = String (wrap lexeme region)

    (* Verbatim strings *)

    let mk_verbatim lexeme region = Verbatim (wrap lexeme region)

    (* Bytes *)

    let mk_bytes lexeme bytes region =
      let value = lexeme, `Hex bytes
      in Bytes (wrap value region)

    (* Integers *)

    let mk_int lexeme z region = Int (wrap (lexeme, z) region)

    (* Natural numbers *)

    type nat_err = Wrong_nat_syntax of string (* Not PascaLIGO *)

    let mk_nat nat z region = Ok (Nat (wrap (nat ^ "n", z) region))

    (* Mutez *)

    type mutez_err = Wrong_mutez_syntax of string (* Not PascaLIGO *)

    let mk_mutez nat ~suffix int64 region =
      Ok (Mutez (wrap (nat ^ suffix, int64) region))

    (* End-Of-File *)

    let mk_eof region = EOF (wrap "" region)

    (* Symbols *)

    type sym_err = Invalid_symbol of string

    let mk_sym lexeme region =
      match lexeme with
        (* Lexemes in common with all concrete syntaxes *)

        ";"   -> Ok (SEMI     (wrap lexeme region))
      | ","   -> Ok (COMMA    (wrap lexeme region))
      | "("   -> Ok (LPAR     (wrap lexeme region))
      | ")"   -> Ok (RPAR     (wrap lexeme region))
      | "["   -> Ok (LBRACKET (wrap lexeme region))
      | "]"   -> Ok (RBRACKET (wrap lexeme region))
      | "{"   -> Ok (LBRACE   (wrap lexeme region))
      | "}"   -> Ok (RBRACE   (wrap lexeme region))
      | "="   -> Ok (EQ       (wrap lexeme region))
      | ":"   -> Ok (COLON    (wrap lexeme region))
      | "|"   -> Ok (VBAR     (wrap lexeme region))
      | "."   -> Ok (DOT      (wrap lexeme region))
      | "_"   -> Ok (WILD     (wrap lexeme region))
      | "+"   -> Ok (PLUS     (wrap lexeme region))
      | "-"   -> Ok (MINUS    (wrap lexeme region))
      | "*"   -> Ok (TIMES    (wrap lexeme region))
      | "/"   -> Ok (SLASH    (wrap lexeme region))
      | "<"   -> Ok (LT       (wrap lexeme region))
      | "<="  -> Ok (LE       (wrap lexeme region))
      | ">"   -> Ok (GT       (wrap lexeme region))
      | ">="  -> Ok (GE       (wrap lexeme region))

      (* Symbols specific to PascaLIGO *)

      | "^"   -> Ok (CARET    (wrap lexeme region))
      | "->"  -> Ok (ARROW    (wrap lexeme region))
      | "=/=" -> Ok (NE       (wrap lexeme region))
      | "#"   -> Ok (SHARP    (wrap lexeme region))
      | ":="  -> Ok (ASS      (wrap lexeme region))

      (* Invalid symbols *)

      | s ->  Error (Invalid_symbol s)


    (* Identifiers *)

    let mk_ident value region =
      match SMap.find_opt value keywords with
        Some mk_kwd -> mk_kwd region
      |        None -> Ident (wrap value region)

    (* Constructors/Modules *)

    let mk_uident value region = UIdent (wrap value region)

    (* Attributes *)

    let mk_attr ~key ?value region = Attr {region; value = key, value}

    (* Code injection *)

    type lang_err = Wrong_lang_syntax of string (* Not PascaLIGO *)

    let mk_lang lang region = Ok (Lang Region.{value=lang; region})

    (* PREDICATES *)

    let is_int    = function Int    _ -> true | _ -> false
    let is_string = function String _ -> true | _ -> false
    let is_bytes  = function Bytes  _ -> true | _ -> false
    let is_eof    = function EOF    _ -> true | _ -> false

    let hex_digits = ["A"; "B"; "C"; "D"; "E"; "F";
                      "a"; "b"; "c"; "d"; "e"; "f"]

    let is_hex = function
      UIdent t | Ident t -> List.mem t#payload hex_digits
    | _ -> false

    let is_sym = function
      SEMI _
    | COMMA _
    | LPAR _
    | RPAR _
    | LBRACE _
    | RBRACE _
    | LBRACKET _
    | RBRACKET _
    | SHARP _
    | VBAR _
    | ARROW _
    | ASS _
    | EQ _
    | COLON _
    | LT _
    | LE _
    | GT _
    | GE _
    | NE _
    | PLUS _
    | MINUS _
    | SLASH _
    | TIMES _
    | DOT _
    | WILD _
    | CARET _ -> true
    | _ -> false

    (* String delimiters *)

    let support_string_delimiter c = (c = '"')

    (* Verbatim strings *)

    let verbatim_delimiters = ("{|", "|}")
  end

include T

module type S = module type of T
