(* Token specification for JsLIGO *)

(* Vendor dependencies *)

module Region    = Simple_utils.Region
module Markup    = LexerLib.Markup
module Directive = LexerLib.Directive

(* Utility modules and types *)

module SMap = Map.Make (String)
module Wrap = Lexing_shared.Wrap
module Attr = Lexing_shared.Attr

let sprintf = Printf.sprintf

let wrap = Wrap.wrap

module T =
  struct
    (* A lexeme is the concrete syntax of a token *)

    type lexeme = string

    (* Definition of tokens generated by "menhir --only-tokens"

       It contains [token] and ['a terminal] types. The first one we
       redefine manually here (by type [t]) but the second one we need
       to satisfy Menhir's Inspection API.  *)

    include Menhir_jsligo_tokens.MenhirToken

    (* TOKENS *)

    type t =
      (* Preprocessing directives *)

      Directive of Directive.t

      (* Comments *)

    | BlockCom of lexeme Wrap.t
    | LineCom  of lexeme Wrap.t

      (* Literals *)

    | String   of lexeme Wrap.t
    | Verbatim of lexeme Wrap.t
    | Bytes    of (lexeme * Hex.t) Wrap.t
    | Int      of (lexeme * Z.t) Wrap.t
 (* | Nat      of (lexeme * Z.t) Wrap.t *)
 (* | Mutez    of (lexeme * Int64.t) Wrap.t *)
    | Ident    of lexeme Wrap.t
    | UIdent   of lexeme Wrap.t
 (* | Lang     of lexeme Region.reg *)
    | Attr     of Attr.t Region.reg

    (* Symbols *)

    | MINUS    of lexeme Wrap.t  (* -    *)
    | PLUS     of lexeme Wrap.t  (* +    *)
    | SLASH    of lexeme Wrap.t  (* /    *)
    | TIMES    of lexeme Wrap.t  (* *    *)
    | REM      of lexeme Wrap.t  (* %    *)
 (* | PLUS2    of lexeme Wrap.t  (* ++   *)
    | MINUS2   of lexeme Wrap.t  (* --   *) *)
    | LPAR     of lexeme Wrap.t  (* (    *)
    | RPAR     of lexeme Wrap.t  (* )    *)
    | LBRACKET of lexeme Wrap.t  (* [    *)
    | RBRACKET of lexeme Wrap.t  (* ]    *)
    | LBRACE   of lexeme Wrap.t  (* {    *)
    | RBRACE   of lexeme Wrap.t  (* }    *)
    | COMMA    of lexeme Wrap.t  (* ,    *)
    | SEMI     of lexeme Wrap.t  (* ;    *)
    | COLON    of lexeme Wrap.t  (* :    *)
    | DOT      of lexeme Wrap.t  (* .    *)
    | ELLIPSIS of lexeme Wrap.t  (* ...  *)
    | BOOL_OR  of lexeme Wrap.t  (* ||   *)
    | BOOL_AND of lexeme Wrap.t  (* &&   *)
    | BOOL_NOT of lexeme Wrap.t  (* !    *)
 (* | BIT_AND  of lexeme Wrap.t  (* &    *)
    | BIT_NOT  of lexeme Wrap.t  (* ~    *)
    | BIT_XOR  of lexeme Wrap.t  (* ^    *)
    | SHIFT_L  of lexeme Wrap.t  (* <<<  *)
    | SHIFT_R  of lexeme Wrap.t  (* >>>  *) *)
    | EQ       of lexeme Wrap.t  (* =    *)
    | EQ2      of lexeme Wrap.t  (* ==   *)
    | NE       of lexeme Wrap.t  (* !=   *)
    | LT       of lexeme Wrap.t  (* <    *)
    | GT       of lexeme Wrap.t  (* >    *)
    | LE       of lexeme Wrap.t  (* <=   *)
    | GE       of lexeme Wrap.t  (* >=   *)
    | PLUS_EQ  of lexeme Wrap.t  (* +=   *)
    | MINUS_EQ of lexeme Wrap.t  (* -=   *)
    | MULT_EQ  of lexeme Wrap.t  (* *=   *)
    | REM_EQ   of lexeme Wrap.t  (* %=   *)
    | DIV_EQ   of lexeme Wrap.t  (* /=   *)
 (* | SL_EQ    of lexeme Wrap.t  (* <<<= *)
    | SR_EQ    of lexeme Wrap.t  (* >>>= *)
    | AND_EQ   of lexeme Wrap.t  (* &=   *)
    | OR_EQ    of lexeme Wrap.t  (* |=   *)
    | XOR_EQ   of lexeme Wrap.t  (* ^=   *) *)
    | VBAR     of lexeme Wrap.t  (* |    *)
    | ARROW    of lexeme Wrap.t  (* =>   *)
    | WILD     of lexeme Wrap.t  (* _    *)

    (* JavaScript Keywords *)

 (* | Break    of lexeme Wrap.t  (* break  *) *)
    | Case     of lexeme Wrap.t  (* case   *)
 (* | Class    of lexeme Wrap.t  (* class  *) *)
    | Const    of lexeme Wrap.t  (* const  *)
    | Default  of lexeme Wrap.t  (* default*)
    | Else     of lexeme Wrap.t  (* else   *)
    | Export   of lexeme Wrap.t  (* export *)
    | For      of lexeme Wrap.t  (* for    *)
    | If       of lexeme Wrap.t  (* if     *)
    | Import   of lexeme Wrap.t  (* import *)
    | Let      of lexeme Wrap.t  (* let    *)
    | Of       of lexeme Wrap.t  (* of     *)
    | Return   of lexeme Wrap.t  (* return *)
    | Break    of lexeme Wrap.t  (* break  *)
    | Switch   of lexeme Wrap.t  (* switch *)
 (* | This     of lexeme Wrap.t  (* this   *) *)
 (* | Void     of lexeme Wrap.t  (* void   *) *)
    | While    of lexeme Wrap.t  (* while  *)
 (* | With     of lexeme Wrap.t  (* with   *)  *)

    (* TypeScript keywords *)

    | As          of lexeme Wrap.t  (* as        *)
    | Namespace   of lexeme Wrap.t  (* namespace *)
    | Type        of lexeme Wrap.t  (* type      *)

    (* Virtual tokens *)

    | ZWSP of lexeme Wrap.t  (* Zero-Width SPace *)

    (* End-Of-File *)

    | EOF of lexeme Wrap.t


    type token = t


    (* FROM TOKENS TO LEXEMES *)

    let to_lexeme = function
      (* Directives *)

      Directive d -> Directive.to_lexeme d

      (* Comments *)

    | LineCom t  -> sprintf "// %s" t#payload
    | BlockCom t -> sprintf "/* %s */" t#payload

      (* Literals *)

    | String t   -> sprintf "%S" t#payload  (* Escaped *)
    | Verbatim t -> String.escaped t#payload
    | Bytes t    -> fst t#payload
    | Int t      -> fst t#payload
    | Ident t
    | UIdent t   -> t#payload
    | Attr t     -> Attr.to_lexeme t.Region.value
 (* | Lang lang  -> "[%" ^ Region.(lang.value.value) *)

    (* Symbols *)

    | MINUS    t
    | PLUS     t
    | SLASH    t
    | TIMES    t
    | REM      t
 (* | PLUS2    t
    | MINUS2   t *)
    | LPAR     t
    | RPAR     t
    | LBRACE   t
    | RBRACE   t
    | LBRACKET t
    | RBRACKET t
    | COMMA    t
    | SEMI     t
    | COLON    t
    | DOT      t
    | ELLIPSIS t
    | BOOL_OR  t
    | BOOL_AND t
    | BOOL_NOT t
 (* | BIT_AND  t
    | BIT_NOT  t
    | BIT_XOR  t
    | SHIFT_L  t
    | SHIFT_R  t *)
    | EQ       t
    | EQ2      t
    | NE       t
    | LT       t
    | GT       t
    | LE       t
    | GE       t
    | PLUS_EQ  t
    | MINUS_EQ t
    | MULT_EQ  t
    | REM_EQ   t
    | DIV_EQ   t
 (* | SL_EQ    t
    | SR_EQ    t
    | AND_EQ   t
    | OR_EQ    t
    | XOR_EQ   t *)
    | VBAR     t
    | ARROW    t
    | WILD     t

    (* JavaScript Keywords *)

 (* | Break    t *)
    | Case     t
 (* | Class    t *)
    | Const    t
    | Default  t
    | Else     t
    | Export   t
    | For      t
    | If       t
    | Import   t
    | Let      t
    | Of       t
    | Return   t
    | Break    t
    | Switch   t
 (* | This     t *)
 (* | Void     t *)
    | While    t
 (* | With     t *)

    (* TypeScript keywords *)

    | As        t
    | Namespace t
    | Type      t -> t#payload

    (* Virtual tokens *)

    | ZWSP _ -> ""

    (* End-Of-File *)

    | EOF _ -> ""


    (* KEYWORDS *)

    (* JavaScript Keywords *)

  (* let mk_Break   region = Break   (wrap "break"   region) *)
     let mk_Case    region = Case    (wrap "case"    region)
  (* let mk_Class   region = Class   (wrap "class"   region) *)
     let mk_Const   region = Const   (wrap "const"   region)
     let mk_Else    region = Else    (wrap "else"    region)
     let mk_Default region = Default (wrap "default" region)
     let mk_Export  region = Export  (wrap "export"  region)
     let mk_For     region = For     (wrap "for"     region)
     let mk_If      region = If      (wrap "if"      region)
     let mk_Import  region = Import  (wrap "import"  region)
     let mk_Let     region = Let     (wrap "let"     region)
     let mk_Of      region = Of      (wrap "of"      region)
     let mk_Return  region = Return  (wrap "return"  region)
     let mk_Break   region = Break   (wrap "break"   region)
     let mk_Switch  region = Switch  (wrap "switch"  region)
  (* let mk_This    region = This    (wrap "this"    region) *)
  (* let mk_Void    region = Void    (wrap "void"    region) *)
     let mk_While   region = While   (wrap "while"   region)
  (* let mk_With    region = With    (wrap "with"    region) *)

     (* TypeScript keywords *)

     let mk_As        region = As        (wrap "as"        region)
     let mk_Namespace region = Namespace (wrap "namespace" region)
     let mk_Type      region = Type      (wrap "type"      region)

     let keywords = [
  (*   mk_Break; *)
       mk_Case;
  (*   mk_Class; *)
       mk_Const;
       mk_Else;
       mk_Default;
       mk_Export;
       mk_For;
       mk_If;
       mk_Import;
       mk_Let;
       mk_Of;
       mk_Return;
       mk_Break;
       mk_Switch;
  (*   mk_This;   *)
  (*   mk_Void;   *)
       mk_While;
  (*   mk_With;   *)

       mk_As;
       mk_Namespace;
       mk_Type
     ]

    let keywords =
     let add map (key, value) = SMap.add key value map in
      let apply map mk_kwd =
        add map (to_lexeme (mk_kwd Region.ghost), mk_kwd)
      in List.fold_left apply SMap.empty keywords

    (* SYMBOLS *)

    let mk_MINUS    region = MINUS    (wrap "-"    region)
    let mk_PLUS     region = PLUS     (wrap "+"    region)
    let mk_SLASH    region = SLASH    (wrap "/"    region)
    let mk_TIMES    region = TIMES    (wrap "*"    region)
    let mk_REM      region = REM      (wrap "%"    region)
 (* let mk_PLUS2    region = PLUS2    (wrap "++"   region)
    let mk_MINUS2   region = MINUS2   (wrap "--"   region) *)
    let mk_LPAR     region = LPAR     (wrap "("    region)
    let mk_RPAR     region = RPAR     (wrap ")"    region)
    let mk_LBRACKET region = LBRACKET (wrap "["    region)
    let mk_RBRACKET region = RBRACKET (wrap "]"    region)
    let mk_LBRACE   region = LBRACE   (wrap "{"    region)
    let mk_RBRACE   region = RBRACE   (wrap "}"    region)
    let mk_COMMA    region = COMMA    (wrap ","    region)
    let mk_SEMI     region = SEMI     (wrap ";"    region)
    let mk_COLON    region = COLON    (wrap ":"    region)
    let mk_DOT      region = DOT      (wrap "."    region)
    let mk_ELLIPSIS region = ELLIPSIS (wrap "..."  region)
    let mk_BOOL_OR  region = BOOL_OR  (wrap "||"   region)
    let mk_BOOL_AND region = BOOL_AND (wrap "&&"   region)
    let mk_BOOL_NOT region = BOOL_NOT (wrap "!"    region)
 (* let mk_BIT_AND  region = BIT_AND  (wrap "&"    region)
    let mk_BIT_NOT  region = BIT_NOT  (wrap "~"    region)
    let mk_BIT_XOR  region = BIT_XOR  (wrap "^"    region)
    let mk_SHIFT_L  region = SHIFT_L  (wrap "<<<"  region)
    let mk_SHIFT_R  region = SHIFT_R  (wrap ">>>"  region) *)
    let mk_EQ       region = EQ       (wrap "="    region)
    let mk_EQ2      region = EQ2      (wrap "=="   region)
    let mk_NE       region = NE       (wrap "!="   region)
    let mk_LT       region = LT       (wrap "<"    region)
    let mk_GT       region = GT       (wrap ">"    region)
    let mk_LE       region = LE       (wrap "<="   region)
    let mk_GE       region = GE       (wrap ">="   region)
    let mk_PLUS_EQ  region = PLUS_EQ  (wrap "+="   region)
    let mk_MINUS_EQ region = MINUS_EQ (wrap "-="   region)
    let mk_MULT_EQ  region = MULT_EQ  (wrap "*="   region)
    let mk_REM_EQ   region = REM_EQ   (wrap "%="   region)
    let mk_DIV_EQ   region = DIV_EQ   (wrap "/="   region)
 (* let mk_SL_EQ    region = SL_EQ    (wrap "<<<=" region)
    let mk_SR_EQ    region = SR_EQ    (wrap ">>>=" region)
    let mk_AND_EQ   region = AND_EQ   (wrap "&="   region)
    let mk_OR_EQ    region = OR_EQ    (wrap "|="   region)
    let mk_XOR_EQ   region = XOR_EQ   (wrap "^="   region) *)
    let mk_VBAR     region = VBAR     (wrap "|"    region)
    let mk_ARROW    region = ARROW    (wrap "=>"   region)
    let mk_WILD     region = WILD     (wrap "_"    region)

    let symbols = [
      mk_MINUS;
      mk_PLUS;
      mk_SLASH;
      mk_TIMES;
      mk_REM;
 (*   mk_PLUS2;
      mk_MINUS2; *)
      mk_LPAR;
      mk_RPAR;
      mk_LBRACKET;
      mk_RBRACKET;
      mk_LBRACE;
      mk_RBRACE;
      mk_COMMA;
      mk_SEMI;
      mk_COLON;
      mk_DOT;
      mk_ELLIPSIS;
      mk_BOOL_OR;
      mk_BOOL_AND;
      mk_BOOL_NOT;
 (*   mk_BIT_AND;
      mk_BIT_NOT;
      mk_BIT_XOR;
      mk_SHIFT_L;
      mk_SHIFT_R;  *)
      mk_EQ;
      mk_EQ2;
      mk_NE;
      mk_LT;
      mk_GT;
      mk_LE;
      mk_GE;
      mk_PLUS_EQ;
      mk_MINUS_EQ;
      mk_MULT_EQ;
      mk_REM_EQ;
      mk_DIV_EQ;
 (*   mk_SL_EQ;
      mk_SR_EQ;
      mk_AND_EQ;
      mk_OR_EQ;
      mk_XOR_EQ;  *)
      mk_VBAR;
      mk_ARROW;
      mk_WILD
    ]

    let symbols =
      let add map (key, value) = SMap.add key value map in
      let apply map mk_kwd =
        add map (to_lexeme (mk_kwd Region.ghost), mk_kwd)
      in List.fold_left apply SMap.empty symbols


    (* GHOST TOKEN ARGUMENTS *)

    (* IMPORTANT: These values cannot be exported in Token.mli *)

    let ghost_String   = Wrap.ghost "\"a string\""
    let ghost_Verbatim = Wrap.ghost "{|verbatim|}"
    let ghost_Bytes    = Wrap.ghost ("0xAA", `Hex "AA")
    let ghost_Int      = Wrap.ghost ("1", Z.one)
    let ghost_Ident    = Wrap.ghost "id"
    let ghost_UIdent   = Wrap.ghost "C"
    let ghost_Attr     = Region.(wrap_ghost (wrap_ghost ("attr", None)))

    let ghost_MINUS    = mk_MINUS    Region.ghost
    let ghost_PLUS     = mk_PLUS     Region.ghost
    let ghost_SLASH    = mk_SLASH    Region.ghost
    let ghost_TIMES    = mk_TIMES    Region.ghost
    let ghost_REM      = mk_REM      Region.ghost
 (* let ghost_PLUS2    = mk_PLUS2    Region.ghost
    let ghost_MINUS2   = mk_MINUS2   Region.ghost *)
    let ghost_LPAR     = mk_LPAR     Region.ghost
    let ghost_RPAR     = mk_RPAR     Region.ghost
    let ghost_LBRACKET = mk_LBRACKET Region.ghost
    let ghost_RBRACKET = mk_RBRACKET Region.ghost
    let ghost_LBRACE   = mk_LBRACE   Region.ghost
    let ghost_RBRACE   = mk_RBRACE   Region.ghost
    let ghost_COMMA    = mk_COMMA    Region.ghost
    let ghost_SEMI     = mk_SEMI     Region.ghost
    let ghost_COLON    = mk_COLON    Region.ghost
    let ghost_DOT      = mk_DOT      Region.ghost
    let ghost_ELLIPSIS = mk_ELLIPSIS Region.ghost
    let ghost_BOOL_OR  = mk_BOOL_OR  Region.ghost
    let ghost_BOOL_AND = mk_BOOL_AND Region.ghost
    let ghost_BOOL_NOT = mk_BOOL_NOT Region.ghost
 (* let ghost_BIT_AND  = mk_BIT_AND  Region.ghost
    let ghost_BIT_NOT  = mk_BIT_NOT  Region.ghost
    let ghost_BIT_XOR  = mk_BIT_XOR  Region.ghost
    let ghost_SHIFT_L  = mk_SHIFT_L  Region.ghost
    let ghost_SHIFT_R  = mk_SHIFT_R  Region.ghost *)
    let ghost_EQ       = mk_EQ       Region.ghost
    let ghost_EQ2      = mk_EQ2      Region.ghost
    let ghost_NE       = mk_NE       Region.ghost
    let ghost_LT       = mk_LT       Region.ghost
    let ghost_GT       = mk_GT       Region.ghost
    let ghost_LE       = mk_LE       Region.ghost
    let ghost_GE       = mk_GE       Region.ghost
    let ghost_PLUS_EQ  = mk_PLUS_EQ  Region.ghost
    let ghost_MINUS_EQ = mk_MINUS_EQ Region.ghost
    let ghost_MULT_EQ  = mk_MULT_EQ  Region.ghost
    let ghost_REM_EQ   = mk_REM_EQ   Region.ghost
    let ghost_DIV_EQ   = mk_DIV_EQ   Region.ghost
 (* let ghost_SL_EQ    = mk_SL_EQ    Region.ghost
    let ghost_SR_EQ    = mk_SR_EQ    Region.ghost
    let ghost_AND_EQ   = mk_AND_EQ   Region.ghost
    let ghost_OR_EQ    = mk_OR_EQ    Region.ghost
    let ghost_XOR_EQ   = mk_XOR_EQ   Region.ghost *)
    let ghost_VBAR     = mk_VBAR     Region.ghost
    let ghost_ARROW    = mk_ARROW    Region.ghost
    let ghost_WILD     = mk_WILD     Region.ghost

    let ghost_EOF = Wrap.ghost ""

    let ghost_Break   = mk_Break   Region.ghost
    let ghost_Case    = mk_Case    Region.ghost
 (* let ghost_Class   = mk_Class   Region.ghost *)
    let ghost_Const   = mk_Const   Region.ghost
    let ghost_Else    = mk_Else    Region.ghost
    let ghost_Default = mk_Default Region.ghost
    let ghost_Export  = mk_Export  Region.ghost
    let ghost_For     = mk_For     Region.ghost
    let ghost_If      = mk_If      Region.ghost
    let ghost_Import  = mk_Import  Region.ghost
    let ghost_Let     = mk_Let     Region.ghost
    let ghost_Of      = mk_Of      Region.ghost
    let ghost_Return  = mk_Return  Region.ghost
    let ghost_Breal   = mk_Break   Region.ghost
    let ghost_Switch  = mk_Switch  Region.ghost
 (* let ghost_This    = mk_This    Region.ghost *)
 (* let ghost_Void    = mk_Void    Region.ghost *)
    let ghost_While   = mk_While   Region.ghost
 (* let ghost_With    = mk_With    Region.ghost *)

    let ghost_As        = mk_As        Region.ghost
    let ghost_Namespace = mk_Namespace Region.ghost
    let ghost_Type      = mk_Type      Region.ghost

    (* FROM TOKEN STRINGS TO LEXEMES *)

    (* TODO: Remove. We don't need fresh variables for syntax checking.

`   let gen_sym prefix =
      let count = ref 0 in
      fun () -> incr count; prefix ^ string_of_int !count

    let id_sym   = gen_sym "id"
    and ctor_sym = gen_sym "C"
     *)

    let concrete = function
      (* Literals *)

      "Ident"    -> ghost_Ident#payload (*id_sym ()*)
    | "UIdent"   -> ghost_UIdent#payload (*ctor_sym ()*)
    | "Int"      -> fst ghost_Int#payload
    | "String"   -> ghost_String#payload
    | "Verbatim" -> ghost_Verbatim#payload
    | "Bytes"    -> fst ghost_Bytes#payload
    | "Attr"     -> Attr.to_lexeme Region.(ghost_Attr.value.value)

    (* Symbols *)

    | "MINUS"    -> to_lexeme ghost_MINUS
    | "PLUS"     -> to_lexeme ghost_PLUS
    | "SLASH"    -> to_lexeme ghost_SLASH
    | "TIMES"    -> to_lexeme ghost_TIMES
    | "REM"      -> to_lexeme ghost_REM
 (* | "PLUS2"    -> to_lexeme ghost_PLUS2
    | "MINUS2"   -> to_lexeme ghost_MINUS2 *)
    | "LPAR"     -> to_lexeme ghost_LPAR
    | "RPAR"     -> to_lexeme ghost_RPAR
    | "LBRACE"   -> to_lexeme ghost_LBRACE
    | "RBRACE"   -> to_lexeme ghost_RBRACE
    | "LBRACKET" -> to_lexeme ghost_LBRACKET
    | "RBRACKET" -> to_lexeme ghost_RBRACKET
    | "COMMA"    -> to_lexeme ghost_COMMA
    | "SEMI"     -> to_lexeme ghost_SEMI
    | "COLON"    -> to_lexeme ghost_COLON
    | "DOT"      -> to_lexeme ghost_DOT
    | "ELLIPSIS" -> to_lexeme ghost_ELLIPSIS
    | "BOOL_OR"  -> to_lexeme ghost_BOOL_OR
    | "BOOL_AND" -> to_lexeme ghost_BOOL_AND
    | "BOOL_NOT" -> to_lexeme ghost_BOOL_NOT
 (* | "BIT_AND"  -> to_lexeme ghost_AND
    | "BIT_NOT"  -> to_lexeme ghost_NOT
    | "BIT_XOR"  -> to_lexeme ghost_XOR
    | "SHIFT_L"  -> to_lexeme ghost_SHIFT_L
    | "SHIFT_R"  -> to_lexeme ghost_SHIFT_R *)
    | "EQ"       -> to_lexeme ghost_EQ
    | "EQ2"      -> to_lexeme ghost_EQ2
    | "NE"       -> to_lexeme ghost_NE
    | "LT"       -> to_lexeme ghost_LT
    | "GT"       -> to_lexeme ghost_GT
    | "LE"       -> to_lexeme ghost_LE
    | "GE"       -> to_lexeme ghost_GE
    | "PLUS_EQ"  -> to_lexeme ghost_PLUS_EQ
    | "MINUS_EQ" -> to_lexeme ghost_MINUS_EQ
    | "MULT_EQ"  -> to_lexeme ghost_MULT_EQ
    | "REM_EQ"   -> to_lexeme ghost_REM_EQ
    | "DIV_EQ"   -> to_lexeme ghost_DIV_EQ
 (* | "SL_EQ"    -> to_lexeme ghost_SL_EQ
    | "SR_EQ"    -> to_lexeme ghost_SR_EQ
    | "AND_EQ"   -> to_lexeme ghost_AND_EQ
    | "OR_EQ"    -> to_lexeme ghost_OR_EQ
    | "XOR_EQ"   -> to_lexeme ghost_XOR_EQ *)
    | "VBAR"     -> to_lexeme ghost_VBAR
    | "ARROW"    -> to_lexeme ghost_ARROW
    | "WILD"     -> to_lexeme ghost_WILD

    (* JavaScript Keywords *)

 (* | "Break"    -> to_lexeme ghost_Break *)
    | "Case"     -> to_lexeme ghost_Case
 (* | "Class"    -> to_lexeme ghost_Class *)
    | "Const"    -> to_lexeme ghost_Const
    | "Default"  -> to_lexeme ghost_Default
    | "Else"     -> to_lexeme ghost_Else
    | "Export"   -> to_lexeme ghost_Export
    | "For"      -> to_lexeme ghost_For
    | "If"       -> to_lexeme ghost_If
    | "Import"   -> to_lexeme ghost_Import
    | "Let"      -> to_lexeme ghost_Let
    | "Of"       -> to_lexeme ghost_Of
    | "Return"   -> to_lexeme ghost_Return
    | "Break"    -> to_lexeme ghost_Break
    | "Switch"   -> to_lexeme ghost_Switch
 (* | "This"     -> to_lexeme ghost_This *)
 (* | "Void"     -> to_lexeme ghost_Void *)
    | "While"    -> to_lexeme ghost_While
 (* | "With"     -> to_lexeme ghost_With *)

    (* TypeScript keywords *)

    | "Type"      -> to_lexeme ghost_Type
    | "Namespace" -> to_lexeme ghost_Namespace
    | "As"        -> to_lexeme ghost_As

    (* Virtual tokens *)

    | "ZWSP" -> ""

    (* End-Of-File *)

    | "EOF" -> ""

    (* This case should not happen! *)

    | _  -> "\\Unknown" (* Backslash meant to trigger an error *)


    (* FROM TOKENS TO TOKEN STRINGS AND REGIONS *)

    let proj_token = function
      (* Preprocessing directives *)

      Directive d -> Directive.project d

      (* Comments *)

    | LineCom t ->
        t#region, sprintf "Line comment %S" t#payload
    | BlockCom t ->
        t#region, sprintf "Block comment %S" t#payload

      (* Literals *)

    | String t ->
        t#region, sprintf "String %S" t#payload
    | Verbatim t ->
        t#region, sprintf "Verbatim %S" t#payload
    | Bytes t ->
        let s, b = t#payload in
        t#region,
        sprintf "Bytes (%S, \"0x%s\")" s (Hex.show b)
    | Int t ->
        let s, n = t#payload in
        t#region, sprintf "Int (%S, %s)" s (Z.to_string n)
 (* | Nat t ->
        let s, n = t#payload in
        t#region, sprintf "Nat (%S, %s)" s (Z.to_string n)
    | Mutez t ->
        let s, n = t#payload in
        t#region, sprintf "Mutez (%S, %s)" s (Int64.to_string n) *)
    | Ident t ->
        t#region, sprintf "Ident %S" t#payload
    | UIdent t ->
        t#region, sprintf "UIdent %S" t#payload
    | Attr {region; value} ->
        region, sprintf "Attr %s" (Attr.to_string value)
 (* | Lang {value = {value = payload; _}; region; _} ->
        region, sprintf "Lang %S" payload *)

    (* Symbols *)

    | MINUS    t -> t#region, "MINUS"
    | PLUS     t -> t#region, "PLUS"
    | SLASH    t -> t#region, "SLASH"
    | TIMES    t -> t#region, "TIMES"
    | REM      t -> t#region, "REM"
 (* | PLUS2    t -> t#region, "PLUS2"
    | MINUS2   t -> t#region, "MINUS2" *)
    | LPAR     t -> t#region, "LPAR"
    | RPAR     t -> t#region, "RPAR"
    | LBRACE   t -> t#region, "LBRACE"
    | RBRACE   t -> t#region, "RBRACE"
    | LBRACKET t -> t#region, "LBRACKET"
    | RBRACKET t -> t#region, "RBRACKET"
    | COMMA    t -> t#region, "COMMA"
    | SEMI     t -> t#region, "SEMI"
    | COLON    t -> t#region, "COLON"
    | DOT      t -> t#region, "DOT"
    | ELLIPSIS t -> t#region, "ELLIPSIS"
    | BOOL_OR  t -> t#region, "BOOL_OR"
    | BOOL_AND t -> t#region, "BOOL_AND"
    | BOOL_NOT t -> t#region, "BOOL_NOT"
 (* | BIT_AND  t -> t#region, "BIT_AND"
    | BIT_NOT  t -> t#region, "BIT_NOT"
    | BIT_XOR  t -> t#region, "BIT_XOR"
    | SHIFT_L  t -> t#region, "SHIFT_L"
    | SHIFT_R  t -> t#region, "SHIFT_R" *)
    | EQ       t -> t#region, "EQ"
    | EQ2      t -> t#region, "EQ2"
    | NE       t -> t#region, "NE"
    | LT       t -> t#region, "LT"
    | GT       t -> t#region, "GT"
    | LE       t -> t#region, "LE"
    | GE       t -> t#region, "GE"
    | PLUS_EQ  t -> t#region, "PLUS_EQ"
    | MINUS_EQ t -> t#region, "MINUS_EQ"
    | MULT_EQ  t -> t#region, "MULT_EQ"
    | REM_EQ   t -> t#region, "REM_EQ"
    | DIV_EQ   t -> t#region, "DIV_EQ"
 (* | SL_EQ    t -> t#region, "SL_EQ"
    | SR_EQ    t -> t#region, "SR_EQ"
    | AND_EQ   t -> t#region, "AND_EQ"
    | OR_EQ    t -> t#region, "OR_EQ"
    | XOR_EQ   t -> t#region, "XOR_EQ" *)
    | VBAR     t -> t#region, "VBAR"
    | ARROW    t -> t#region, "ARROW"
    | WILD     t -> t#region, "WILD"

    (* JavaScript Keywords *)

 (* | Break    t -> t#region, "Break" *)
    | Case     t -> t#region, "Case"
 (* | Class    t -> t#region, "Class" *)
    | Const    t -> t#region, "Const"
    | Default  t -> t#region, "Default"
    | Else     t -> t#region, "Else"
    | Export   t -> t#region, "Export"
    | For      t -> t#region, "For"
    | If       t -> t#region, "If"
    | Import   t -> t#region, "Import"
    | Let      t -> t#region, "Let"
    | Of       t -> t#region, "Of"
    | Return   t -> t#region, "Return"
    | Break    t -> t#region, "Break"
    | Switch   t -> t#region, "Switch"
 (* | This     t -> t#region, "This" *)
 (* | Void     t -> t#region, "Void" *)
    | While    t -> t#region, "While"
 (* | With     t -> t#region, "With" *)

    (* TypeScript keywords *)

    | As          t -> t#region, "As"
    | Namespace   t -> t#region, "Namespace"
    | Type        t -> t#region, "Type"

    (* Virtual tokens *)

    | ZWSP t -> t#region, "ZWSP"

    (* End-Of-File *)

    | EOF t -> t#region, "EOF"


    (* CONVERSIONS *)

    let to_string ~offsets mode token =
      let region, val_str = proj_token token in
      let reg_str = region#compact ~offsets mode
      in sprintf "%s: %s" reg_str val_str

    let to_region token = proj_token token |> fst

    (* SMART CONSTRUCTORS *)

    (* Keywords *)

    type kwd_err = Invalid_keyword

    let mk_kwd ident region =
      match SMap.find_opt ident keywords with
        Some mk_kwd -> Ok (mk_kwd region)
      |        None -> Error Invalid_keyword

    (* Directives *)

    let mk_directive dir = Directive dir

    (* Strings *)

    let mk_string lexeme region = String (wrap lexeme region)

    (* Verbatim strings *)

    let mk_verbatim lexeme region = Verbatim (wrap lexeme region)

    (* Bytes *)

    let mk_bytes lexeme bytes region =
      Bytes (wrap (lexeme, `Hex bytes) region)

    (* Integers *)

    let mk_int lexeme z region = Int (wrap (lexeme, z) region)

    (* Natural numbers *)

    type nat_err = Wrong_nat_syntax of string

    let mk_nat _nat _z _region =
      Error (Wrong_nat_syntax "Example: \"12334 as nat\".")

    (* Mutez *)

    type mutez_err = Wrong_mutez_syntax of string

    let mk_mutez _nat ~suffix:_ _int64 _region =
      Error (Wrong_mutez_syntax "Example: \"1234 as mutez\".")

    (* End-Of-File *)

    let mk_eof region = EOF (wrap "" region)

    (* Symbols *)

    type sym_err = Invalid_symbol of string

    let mk_sym lexeme region =
      match SMap.find_opt lexeme symbols with
        Some mk_sym -> Ok (mk_sym region)
      |        None -> Error (Invalid_symbol lexeme)

    (* Identifiers *)

    let mk_ident value region =
      match SMap.find_opt value keywords with
        Some mk_kwd -> mk_kwd region
      |        None -> Ident (wrap value region)

    (* Constructors/Modules *)

    let mk_uident value region = UIdent (wrap value region)

    (* Attributes *)

    let mk_attr ~key ?value region = Attr {region; value = key, value}

    (* Code injection *)

    type lang_err = Wrong_lang_syntax of string

    let mk_lang _lang _region =
      Error (Wrong_lang_syntax
               "Example: \"(Michelson `{UNPAIR; ADD}`\
                         as ((n: [nat, nat]) => nat))\".")

    (* PREDICATES *)

    let is_int    = function Int    _ -> true | _ -> false
    let is_string = function String _ -> true | _ -> false
    let is_bytes  = function Bytes  _ -> true | _ -> false
    let is_eof    = function EOF    _ -> true | _ -> false

    let hex_digits = ["A"; "B"; "C"; "D"; "E"; "F";
                      "a"; "b"; "c"; "d"; "e"; "f"]

    let is_hex = function
      UIdent t | Ident t -> List.mem t#payload hex_digits
    | _ -> false

    let is_sym = function
      MINUS _
    | PLUS _
    | SLASH _
    | TIMES _
    | REM _
 (* | PLUS2 _
    | MINUS2 _ *)
    | LPAR _
    | RPAR _
    | LBRACKET _
    | RBRACKET _
    | LBRACE _
    | RBRACE _
    | COMMA _
    | SEMI _
    | COLON _
    | DOT _
    | ELLIPSIS _
    | BOOL_OR _
    | BOOL_AND _
    | BOOL_NOT _
 (* | BIT_AND _
    | BIT_NOT _
    | BIT_XOR _
    | SHIFT_L _
    | SHIFT_R _ *)
    | EQ _
    | EQ2 _
    | NE _
    | LT _
    | GT _
    | LE _
    | GE _
 (* | PLUS_EQ _
    | MINUS_EQ _
    | MULT_EQ _
    | REM_EQ _
    | DIV_EQ _
    | SL_EQ _
    | SR_EQ _
    | AND_EQ _
    | OR_EQ _
    | XOR_EQ _ *)
    | VBAR _
    | ARROW _
    | WILD _ -> true
    | _ -> false

    (* String delimiters *)

    let support_string_delimiter c = (c = '"')

    (* Verbatim strings *)

    let verbatim_delimiters = ("{|", "|}")
  end

include T

module type S = module type of T
